(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by psc-bundle 0.7.4.1
var PS = { };
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var NoOp = (function () {
      function NoOp() {

      };
      NoOp.value = new NoOp();
      return NoOp;
  })();
  var Add = (function () {
      function Add(value0) {
          this.value0 = value0;
      };
      Add.create = function (value0) {
          return new Add(value0);
      };
      return Add;
  })();
  var Delete = (function () {
      function Delete(value0) {
          this.value0 = value0;
      };
      Delete.create = function (value0) {
          return new Delete(value0);
      };
      return Delete;
  })();
  var Check = (function () {
      function Check(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Check.create = function (value0) {
          return function (value1) {
              return new Check(value0, value1);
          };
      };
      return Check;
  })();
  var ChangedInput = (function () {
      function ChangedInput(value0) {
          this.value0 = value0;
      };
      ChangedInput.create = function (value0) {
          return new ChangedInput(value0);
      };
      return ChangedInput;
  })();
  var DeleteCompleted = (function () {
      function DeleteCompleted() {

      };
      DeleteCompleted.value = new DeleteCompleted();
      return DeleteCompleted;
  })();
  var Edit = (function () {
      function Edit(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Edit.create = function (value0) {
          return function (value1) {
              return new Edit(value0, value1);
          };
      };
      return Edit;
  })();
  var ChangeDescription = (function () {
      function ChangeDescription(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ChangeDescription.create = function (value0) {
          return function (value1) {
              return new ChangeDescription(value0, value1);
          };
      };
      return ChangeDescription;
  })();
  var ChangeFilter = (function () {
      function ChangeFilter(value0) {
          this.value0 = value0;
      };
      ChangeFilter.create = function (value0) {
          return new ChangeFilter(value0);
      };
      return ChangeFilter;
  })();
  exports["NoOp"] = NoOp;
  exports["Add"] = Add;
  exports["Delete"] = Delete;
  exports["Check"] = Check;
  exports["ChangedInput"] = ChangedInput;
  exports["DeleteCompleted"] = DeleteCompleted;
  exports["Edit"] = Edit;
  exports["ChangeDescription"] = ChangeDescription;
  exports["ChangeFilter"] = ChangeFilter;;
 
})(PS["Action"] = PS["Action"] || {});
(function(exports) {
  // module Signal.Channel

  exports.channelP =
    function channelP(constant) {
      return function(v) {
        return function() {
          return constant(v);
        };
      };
    };

  exports.sendP =
    function sendP(chan, v) {
      return function(v) {
        return function() {
          chan.set(v);
        };
      };
    };

  exports.subscribe =
    function subscribe(chan) {
      return chan;
    };
 
})(PS["Signal.Channel"] = PS["Signal.Channel"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Control.Monad.Eff

  exports.returnE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };

  exports.runPure = function (f) {
    return f();
  };
 
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  //- Show -----------------------------------------------------------------------

  exports.showIntImpl = function (n) {
    return n.toString();
  };
 
})(PS["Prelude"] = PS["Prelude"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Prelude"];
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var Category = function (__superclass_Prelude$dotSemigroupoid_0, id) {
      this["__superclass_Prelude.Semigroupoid_0"] = __superclass_Prelude$dotSemigroupoid_0;
      this.id = id;
  };
  var Functor = function (map) {
      this.map = map;
  };
  var Apply = function (__superclass_Prelude$dotFunctor_0, apply) {
      this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
      this.apply = apply;
  };
  var Applicative = function (__superclass_Prelude$dotApply_0, pure) {
      this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
      this.pure = pure;
  };
  var Bind = function (__superclass_Prelude$dotApply_0, bind) {
      this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
      this.bind = bind;
  };
  var Monad = function (__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
      this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
      this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
  };
  var Show = function (show) {
      this.show = show;
  };                                                                           
  var unit = {};                                     
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };                                                                     
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });                 
  var pure = function (dict) {
      return dict.pure;
  };
  var $$return = function (__dict_Applicative_2) {
      return pure(__dict_Applicative_2);
  };
  var otherwise = true;
  var map = function (dict) {
      return dict.map;
  };
  var $less$dollar$greater = function (__dict_Functor_5) {
      return map(__dict_Functor_5);
  };
  var id = function (dict) {
      return dict.id;
  };                                                
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (_32) {
          return a;
      };
  };
  var compose = function (dict) {
      return dict.compose;
  };
  var functorFn = new Functor(compose(semigroupoidFn));
  var categoryFn = new Category(function () {
      return semigroupoidFn;
  }, function (x) {
      return x;
  });
  var bind = function (dict) {
      return dict.bind;
  };
  var $greater$greater$eq = function (__dict_Bind_24) {
      return bind(__dict_Bind_24);
  }; 
  var apply = function (dict) {
      return dict.apply;
  };
  var $less$times$greater = function (__dict_Apply_25) {
      return apply(__dict_Apply_25);
  };
  var liftA1 = function (__dict_Applicative_26) {
      return function (f) {
          return function (a) {
              return $less$times$greater(__dict_Applicative_26["__superclass_Prelude.Apply_0"]())(pure(__dict_Applicative_26)(f))(a);
          };
      };
  }; 
  var append = function (dict) {
      return dict.append;
  };
  var $less$greater = function (__dict_Semigroup_28) {
      return append(__dict_Semigroup_28);
  };
  var ap = function (__dict_Monad_30) {
      return function (f) {
          return function (a) {
              return bind(__dict_Monad_30["__superclass_Prelude.Bind_1"]())(f)(function (_11) {
                  return bind(__dict_Monad_30["__superclass_Prelude.Bind_1"]())(a)(function (_10) {
                      return $$return(__dict_Monad_30["__superclass_Prelude.Applicative_0"]())(_11(_10));
                  });
              });
          };
      };
  };
  exports["Show"] = Show;
  exports["Monad"] = Monad;
  exports["Bind"] = Bind;
  exports["Applicative"] = Applicative;
  exports["Apply"] = Apply;
  exports["Functor"] = Functor;
  exports["Category"] = Category;
  exports["Semigroupoid"] = Semigroupoid;
  exports["show"] = show;
  exports["<>"] = $less$greater;
  exports["append"] = append;
  exports["ap"] = ap;
  exports["return"] = $$return;
  exports[">>="] = $greater$greater$eq;
  exports["bind"] = bind;
  exports["liftA1"] = liftA1;
  exports["pure"] = pure;
  exports["<*>"] = $less$times$greater;
  exports["apply"] = apply;
  exports["<$>"] = $less$dollar$greater;
  exports["map"] = map;
  exports["id"] = id;
  exports["compose"] = compose;
  exports["otherwise"] = otherwise;
  exports["const"] = $$const;
  exports["flip"] = flip;
  exports["unit"] = unit;
  exports["semigroupoidFn"] = semigroupoidFn;
  exports["categoryFn"] = categoryFn;
  exports["functorFn"] = functorFn;
  exports["showInt"] = showInt;;
 
})(PS["Prelude"] = PS["Prelude"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Control.Monad.Eff"];
  var Prelude = PS["Prelude"];     
  var monadEff = new Prelude.Monad(function () {
      return applicativeEff;
  }, function () {
      return bindEff;
  });
  var bindEff = new Prelude.Bind(function () {
      return applyEff;
  }, $foreign.bindE);
  var applyEff = new Prelude.Apply(function () {
      return functorEff;
  }, Prelude.ap(monadEff));
  var applicativeEff = new Prelude.Applicative(function () {
      return applyEff;
  }, $foreign.returnE);
  var functorEff = new Prelude.Functor(Prelude.liftA1(applicativeEff));
  exports["functorEff"] = functorEff;
  exports["applyEff"] = applyEff;
  exports["applicativeEff"] = applicativeEff;
  exports["bindEff"] = bindEff;
  exports["monadEff"] = monadEff;
  exports["runPure"] = $foreign.runPure;;
 
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // module Signal

  exports.constant =
    function constant(initial) {
      var subs = [];
      var val = initial;
      var sig = {
        subscribe: function(sub) {
          subs.push(sub);
          sub(val);
        },
        get: function() { return val; },
        set: function(newval) {
          val = newval;
          subs.forEach(function(sub) { sub(newval); });
        }
      };
      return sig;
    };

  exports.mapSigP =
    function mapSigP(constant) {
      return function(fun) {
        return function(sig) {
          var out = constant(fun(sig.get()));
          sig.subscribe(function(val) { out.set(fun(val)); });
          return out;
        };
      };
    };

  exports.foldpP =
    function foldpP(constant) {
      return function(fun) {
        return function(seed) {
          return function(sig) {
            var acc = seed;
            var out = constant(acc);
            sig.subscribe(function(val) {
              acc = fun(val)(acc);
              out.set(acc);
            });
            return out;
          };
        };
      };
    };

  exports.runSignal =
    function runSignal(sig) {
      return function() {
        sig.subscribe(function(val) {
          val();
        });
        return {};
      };
    };
 
})(PS["Signal"] = PS["Signal"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Data.Foldable

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
 
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Prelude = PS["Prelude"];
  var $times$greater = function (__dict_Apply_1) {
      return function (a) {
          return function (b) {
              return Prelude["<*>"](__dict_Apply_1)(Prelude["<$>"](__dict_Apply_1["__superclass_Prelude.Functor_0"]())(Prelude["const"](Prelude.id(Prelude.categoryFn)))(a))(b);
          };
      };
  };
  exports["*>"] = $times$greater;;
 
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Prelude = PS["Prelude"];
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["mempty"] = mempty;;
 
})(PS["Data.Monoid"] = PS["Data.Monoid"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Extend = PS["Control.Extend"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];     
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (b) {
      return function (f) {
          return function (_143) {
              if (_143 instanceof Nothing) {
                  return b;
              };
              if (_143 instanceof Just) {
                  return f(_143.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe line 26, column 1 - line 27, column 1: " + [ b.constructor.name, f.constructor.name, _143.constructor.name ]);
          };
      };
  };                                                   
  var isJust = maybe(false)(Prelude["const"](true));
  var functorMaybe = new Prelude.Functor(function (fn) {
      return function (_145) {
          if (_145 instanceof Just) {
              return new Just(fn(_145.value0));
          };
          return Nothing.value;
      };
  });
  var applyMaybe = new Prelude.Apply(function () {
      return functorMaybe;
  }, function (_146) {
      return function (x) {
          if (_146 instanceof Just) {
              return Prelude["<$>"](functorMaybe)(_146.value0)(x);
          };
          if (_146 instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe line 121, column 1 - line 145, column 1: " + [ _146.constructor.name, x.constructor.name ]);
      };
  });
  var bindMaybe = new Prelude.Bind(function () {
      return applyMaybe;
  }, function (_148) {
      return function (k) {
          if (_148 instanceof Just) {
              return k(_148.value0);
          };
          if (_148 instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe line 180, column 1 - line 199, column 1: " + [ _148.constructor.name, k.constructor.name ]);
      };
  });
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["isJust"] = isJust;
  exports["maybe"] = maybe;
  exports["functorMaybe"] = functorMaybe;
  exports["applyMaybe"] = applyMaybe;
  exports["bindMaybe"] = bindMaybe;;
 
})(PS["Data.Maybe"] = PS["Data.Maybe"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Data.Foldable"];
  var Prelude = PS["Prelude"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];     
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var traverse_ = function (__dict_Applicative_0) {
      return function (__dict_Foldable_1) {
          return function (f) {
              return foldr(__dict_Foldable_1)(function (_818) {
                  return Control_Apply["*>"](__dict_Applicative_0["__superclass_Prelude.Apply_0"]())(f(_818));
              })(Prelude.pure(__dict_Applicative_0)(Prelude.unit));
          };
      };
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldableArray = new Foldable(function (__dict_Monoid_19) {
      return function (f) {
          return function (xs) {
              return foldr(foldableArray)(function (x) {
                  return function (acc) {
                      return Prelude["<>"](__dict_Monoid_19["__superclass_Prelude.Semigroup_0"]())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(__dict_Monoid_19))(xs);
          };
      };
  }, $foreign.foldlArray, $foreign.foldrArray);
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  exports["Foldable"] = Foldable;
  exports["traverse_"] = traverse_;
  exports["foldMap"] = foldMap;
  exports["foldl"] = foldl;
  exports["foldr"] = foldr;
  exports["foldableArray"] = foldableArray;;
 
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Signal"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Prelude = PS["Prelude"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Maybe = PS["Data.Maybe"];     
  var $tilde$greater = function (__dict_Functor_0) {
      return Prelude.flip(Prelude["<$>"](__dict_Functor_0));
  };                                                 
  var mapSig = $foreign.mapSigP($foreign.constant);
  var functorSignal = new Prelude.Functor(mapSig);
  var foldp = $foreign.foldpP($foreign.constant);
  exports["~>"] = $tilde$greater;
  exports["foldp"] = foldp;
  exports["functorSignal"] = functorSignal;
  exports["runSignal"] = $foreign.runSignal;
  exports["constant"] = $foreign.constant;;
 
})(PS["Signal"] = PS["Signal"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Signal.Channel"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Prelude = PS["Prelude"];
  var Signal = PS["Signal"];     
  var send = $foreign.sendP;
  var channel = $foreign.channelP(Signal.constant);
  exports["send"] = send;
  exports["channel"] = channel;
  exports["subscribe"] = $foreign.subscribe;;
 
})(PS["Signal.Channel"] = PS["Signal.Channel"] || {});
(function(exports) {
  var IDom = require('incremental-dom');

  // module Incremental.DOM

  function unfoldAttributes (attributes) {
      return attributes.reduce(function (attrs, v) {
          var a = v.value0;
          var val = a.value;
          var name = a.name;
          var isStatic = a.static;
          if (name === 'value') {
              val = new String(val);
          }

          if(val === '__UNSET__') {
              //ignore
          } else if (name === 'key') {
              attrs.key = val;
          } else if (isStatic) {
              attrs.statics.push(name);
              attrs.statics.push(val);
          } else {
              attrs.attributes.push(name);
              var valueToPush = val;
              if(typeof valueToPush === 'function') {
                  valueToPush = function(event) {
                      var effect = val(event);
                      effect();
                  };
              }
              attrs.attributes.push(valueToPush);
          }
          return attrs;
      }, {statics : [], key: null, attributes: []});
  }

  exports.element = function (tagName) {
          return function (attrs) {
              return function (children) {
                  return function() {
                      var unfoldedAttrs = unfoldAttributes(attrs);
                      var args = [tagName, unfoldedAttrs.key, unfoldedAttrs.statics].concat(unfoldedAttrs.attributes);
                      IDom.elementOpen.apply(null, args);
                      children();
                      return IDom.elementClose(tagName);
                  };
              };
          };
  };

  exports.text = function(text) {
      return function() {
          return IDom.text(text);
      };
  };


  exports.patch = function (iRootElement) {
      return function (domElement) {
          return function iDomEffect() {
              IDom.patch(domElement, iRootElement, {});
              return {};
          }
      };
  };
 
})(PS["Incremental.DOM"] = PS["Incremental.DOM"] || {});
(function(exports) {
  //module Incremental.Attributes

  exports.objPropAccessorImpl = function (just) {
      return function (nothing) {
          return function (prop) {
              return function (obj) {
                  if (obj[prop] != null) {
                      return just(obj[prop]);
                  } else {
                      return nothing;
                  }
              };
          };
      };
  };
 
})(PS["Incremental.Attributes"] = PS["Incremental.Attributes"] || {});
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function(x) { return x; }
 
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;;
 
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Incremental.Attributes"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var IAttribute = (function () {
      function IAttribute(value0) {
          this.value0 = value0;
      };
      IAttribute.create = function (value0) {
          return new IAttribute(value0);
      };
      return IAttribute;
  })();
  var unsafeObjPropAccessor = $foreign.objPropAccessorImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var toAttributeValue = Unsafe_Coerce.unsafeCoerce;
  var stringAttribute = function (name_1) {
      return function ($$static) {
          return function (value_1) {
              return new IAttribute({
                  name: name_1, 
                  value: toAttributeValue(value_1), 
                  "static": $$static
              });
          };
      };
  };                                          
  var type$prime = stringAttribute("type")(true);
  var value = stringAttribute("value")(false);
  var volatileAttribute = function (name_1) {
      return function (visible) {
          return stringAttribute(name_1)(false)((function () {
              if (visible) {
                  return name_1;
              };
              if (!visible) {
                  return "__UNSET__";
              };
              throw new Error("Failed pattern match at Incremental.Attributes line 71, column 1 - line 72, column 1: " + [ visible.constructor.name ]);
          })());
      };
  };                                           
  var placeholder = stringAttribute("placeholder")(false);
  var orDefault = function (defaultVal) {
      return function (ma) {
          if (ma instanceof Data_Maybe.Just) {
              return ma.value0;
          };
          if (ma instanceof Data_Maybe.Nothing) {
              return defaultVal;
          };
          throw new Error("Failed pattern match at Incremental.Attributes line 205, column 1 - line 206, column 1: " + [ ma.constructor.name ]);
      };
  };
  var targetValue = function (event) {
      return orDefault("")(Prelude.bind(Data_Maybe.bindMaybe)(unsafeObjPropAccessor("target")(event))(function (_0) {
          return unsafeObjPropAccessor("value")(_0);
      }));
  };
  var name = stringAttribute("name")(true);
  var key = stringAttribute("key")(false); 
  var eventAttribute = function (name_1) {
      return function (handler) {
          return new IAttribute({
              name: name_1, 
              value: toAttributeValue(handler), 
              "static": false
          });
      };
  };
  var on$prime = eventAttribute;
  var on = function (eventName) {
      return function (effect) {
          return on$prime(eventName)(function (_6) {
              return effect;
          });
      };
  };
  var onBlur = on("onblur");    
  var onClick = on("onclick");
  var onDoubleClick = on("ondblclick");         
  var onInput$prime = on$prime("oninput");
  var class$prime = stringAttribute("class")(false);
  var checked = volatileAttribute("checked");
  exports["targetValue"] = targetValue;
  exports["onBlur"] = onBlur;
  exports["onInput'"] = onInput$prime;
  exports["onDoubleClick"] = onDoubleClick;
  exports["onClick"] = onClick;
  exports["on"] = on;
  exports["placeholder"] = placeholder;
  exports["name"] = name;
  exports["checked"] = checked;
  exports["value"] = value;
  exports["key"] = key;
  exports["type'"] = type$prime;
  exports["class'"] = class$prime;;
 
})(PS["Incremental.Attributes"] = PS["Incremental.Attributes"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Incremental.DOM"];
  var Prelude = PS["Prelude"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Data_Array = PS["Data.Array"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var DOM = PS["DOM"];     
  var iempty = Prelude["return"](Control_Monad_Eff.applicativeEff)(Prelude.unit);
  exports["iempty"] = iempty;
  exports["patch"] = $foreign.patch;
  exports["text"] = $foreign.text;
  exports["element"] = $foreign.element;;
 
})(PS["Incremental.DOM"] = PS["Incremental.DOM"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Incremental_DOM = PS["Incremental.DOM"];
  var ul = Incremental_DOM.element("ul");        
  var span$prime = Incremental_DOM.element("span");
  var li = Incremental_DOM.element("li");        
  var label = Incremental_DOM.element("label");
  var input = Incremental_DOM.element("input");
  var div$prime = Incremental_DOM.element("div");
  var button = Incremental_DOM.element("button");
  exports["ul"] = ul;
  exports["span'"] = span$prime;
  exports["li"] = li;
  exports["label"] = label;
  exports["input"] = input;
  exports["div'"] = div$prime;
  exports["button"] = button;;
 
})(PS["Incremental.Elements"] = PS["Incremental.Elements"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Signal_Channel = PS["Signal.Channel"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Action = PS["Action"];     
  var taskAdder = function (chan) {
      return function (val) {
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("task-adder") ])(function __do() {
              Incremental_Elements.input([ Incremental_Attributes["type'"]("text"), Incremental_Attributes.value(val), Incremental_Attributes["onInput'"](function (_1) {
                  return Signal_Channel.send(chan)(Action.ChangedInput.create(Incremental_Attributes.targetValue(_1)));
              }) ])(Incremental_DOM.iempty)();
              return Incremental_Elements.button([ Incremental_Attributes["type'"]("button"), Incremental_Attributes.onClick(Signal_Channel.send(chan)(new Action.Add(val))) ])(Incremental_DOM.text("Add todo"))();
          });
      };
  };
  exports["taskAdder"] = taskAdder;;
 
})(PS["Components.TaskAdder"] = PS["Components.TaskAdder"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Traversable = PS["Data.Traversable"];     
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  exports["Tuple"] = Tuple;;
 
})(PS["Data.Tuple"] = PS["Data.Tuple"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Traversable = PS["Data.Traversable"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_MonadPlus = PS["Control.MonadPlus"];     
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var toList = function (__dict_Foldable_2) {
      return Data_Foldable.foldr(__dict_Foldable_2)(Cons.create)(Nil.value);
  }; 
  var reverse = (function () {
      var go = function (__copy_acc) {
          return function (__copy__380) {
              var acc = __copy_acc;
              var _380 = __copy__380;
              tco: while (true) {
                  var acc_1 = acc;
                  if (_380 instanceof Nil) {
                      return acc_1;
                  };
                  if (_380 instanceof Cons) {
                      var __tco_acc = new Cons(_380.value0, acc);
                      var __tco__380 = _380.value1;
                      acc = __tco_acc;
                      _380 = __tco__380;
                      continue tco;
                  };
                  throw new Error("Failed pattern match at Data.List line 364, column 1 - line 365, column 1: " + [ acc.constructor.name, _380.constructor.name ]);
              };
          };
      };
      return go(Nil.value);
  })();
  var foldableList = new Data_Foldable.Foldable(function (__dict_Monoid_16) {
      return function (f) {
          return Data_Foldable.foldl(foldableList)(function (acc) {
              return function (_1658) {
                  return Prelude.append(__dict_Monoid_16["__superclass_Prelude.Semigroup_0"]())(acc)(f(_1658));
              };
          })(Data_Monoid.mempty(__dict_Monoid_16));
      };
  }, (function () {
      var go = function (__copy_o) {
          return function (__copy_b) {
              return function (__copy__405) {
                  var o = __copy_o;
                  var b = __copy_b;
                  var _405 = __copy__405;
                  tco: while (true) {
                      var b_1 = b;
                      if (_405 instanceof Nil) {
                          return b_1;
                      };
                      if (_405 instanceof Cons) {
                          var __tco_o = o;
                          var __tco_b = o(b)(_405.value0);
                          var __tco__405 = _405.value1;
                          o = __tco_o;
                          b = __tco_b;
                          _405 = __tco__405;
                          continue tco;
                      };
                      throw new Error("Failed pattern match: " + [ o.constructor.name, b.constructor.name, _405.constructor.name ]);
                  };
              };
          };
      };
      return go;
  })(), function (o) {
      return function (b) {
          return function (_404) {
              if (_404 instanceof Nil) {
                  return b;
              };
              if (_404 instanceof Cons) {
                  return o(_404.value0)(Data_Foldable.foldr(foldableList)(o)(b)(_404.value1));
              };
              throw new Error("Failed pattern match: " + [ o.constructor.name, b.constructor.name, _404.constructor.name ]);
          };
      };
  });
  var length = Data_Foldable.foldl(foldableList)(function (acc) {
      return function (_347) {
          return acc + 1 | 0;
      };
  })(0);
  var filter = function (p) {
      var go = function (__copy_acc) {
          return function (__copy__381) {
              var acc = __copy_acc;
              var _381 = __copy__381;
              tco: while (true) {
                  var acc_1 = acc;
                  if (_381 instanceof Nil) {
                      return reverse(acc_1);
                  };
                  if (_381 instanceof Cons) {
                      if (p(_381.value0)) {
                          var __tco_acc = new Cons(_381.value0, acc);
                          var __tco__381 = _381.value1;
                          acc = __tco_acc;
                          _381 = __tco__381;
                          continue tco;
                      };
                      if (Prelude.otherwise) {
                          var __tco_acc = acc;
                          var __tco__381 = _381.value1;
                          acc = __tco_acc;
                          _381 = __tco__381;
                          continue tco;
                      };
                  };
                  throw new Error("Failed pattern match at Data.List line 387, column 1 - line 388, column 1: " + [ acc.constructor.name, _381.constructor.name ]);
              };
          };
      };
      return go(Nil.value);
  };
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["filter"] = filter;
  exports["reverse"] = reverse;
  exports["length"] = length;
  exports["toList"] = toList;
  exports["foldableList"] = foldableList;;
 
})(PS["Data.List"] = PS["Data.List"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports._copyEff = function (m) {
    return function () {
      var r = {};
      for (var k in m) {
        if (m.hasOwnProperty(k)) {
          r[k] = m[k];
        }
      }
      return r;
    };
  };

  exports.empty = {};

  exports.runST = function (f) {
    return f;
  };

  // jshint maxparams: 4
  exports._lookup = function (no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  };

  function _collect (f) {
    return function (m) {
      var r = [];
      for (var k in m) {
        if (m.hasOwnProperty(k)) {
          r.push(f(k)(m[k]));
        }
      }
      return r;
    };
  }

  exports._collect = _collect;

  exports.keys = Object.keys || _collect(function (k) {
    return function () { return k; };
  });
 
})(PS["Data.StrMap"] = PS["Data.StrMap"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports.runFn4 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return fn(a, b, c, d);
          };
        };
      };
    };
  };
 
})(PS["Data.Function"] = PS["Data.Function"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Data.Function"];
  var Prelude = PS["Prelude"];
  exports["runFn4"] = $foreign.runFn4;;
 
})(PS["Data.Function"] = PS["Data.Function"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports.poke = function (m) {
    return function (k) {
      return function (v) {
        return function () {
          m[k] = v;
          return m;
        };
      };
    };
  };

  exports["delete"] = function (m) {
    return function (k) {
      return function () {
        delete m[k];
        return m;
      };
    };
  };
 
})(PS["Data.StrMap.ST"] = PS["Data.StrMap.ST"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Data.StrMap.ST"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  exports["delete"] = $foreign["delete"];
  exports["poke"] = $foreign.poke;;
 
})(PS["Data.StrMap.ST"] = PS["Data.StrMap.ST"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Data.StrMap"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_List = PS["Data.List"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_StrMap_ST = PS["Data.StrMap.ST"];     
  var values = function (_2237) {
      return Data_List.toList(Data_Foldable.foldableArray)($foreign._collect(function (_441) {
          return function (v) {
              return v;
          };
      })(_2237));
  };
  var toList = function (_2238) {
      return Data_List.toList(Data_Foldable.foldableArray)($foreign._collect(Data_Tuple.Tuple.create)(_2238));
  };
  var thawST = $foreign._copyEff;
  var pureST = function (f) {
      return Control_Monad_Eff.runPure($foreign.runST(f));
  };
  var mutate = function (f) {
      return function (m) {
          return pureST(function __do() {
              var _18 = thawST(m)();
              f(_18)();
              return Prelude["return"](Control_Monad_Eff.applicativeEff)(_18)();
          });
      };
  };                                                                                 
  var lookup = Data_Function.runFn4($foreign._lookup)(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
  var insert = function (k) {
      return function (v) {
          return mutate(function (s) {
              return Data_StrMap_ST.poke(s)(k)(v);
          });
      };
  };
  var $$delete = function (k) {
      return mutate(function (s) {
          return Data_StrMap_ST["delete"](s)(k);
      });
  };
  var alter = function (f) {
      return function (k) {
          return function (m) {
              var _2235 = f(lookup(k)(m));
              if (_2235 instanceof Data_Maybe.Nothing) {
                  return $$delete(k)(m);
              };
              if (_2235 instanceof Data_Maybe.Just) {
                  return insert(k)(_2235.value0)(m);
              };
              throw new Error("Failed pattern match at Data.StrMap line 175, column 1 - line 176, column 1: " + [ _2235.constructor.name ]);
          };
      };
  };
  var update = function (f) {
      return function (k) {
          return function (m) {
              return alter(Data_Maybe.maybe(Data_Maybe.Nothing.value)(f))(k)(m);
          };
      };
  };
  exports["thawST"] = thawST;
  exports["values"] = values;
  exports["update"] = update;
  exports["alter"] = alter;
  exports["delete"] = $$delete;
  exports["toList"] = toList;
  exports["lookup"] = lookup;
  exports["insert"] = insert;
  exports["keys"] = $foreign.keys;
  exports["empty"] = $foreign.empty;;
 
})(PS["Data.StrMap"] = PS["Data.StrMap"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Action = PS["Action"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_StrMap = PS["Data.StrMap"];
  var Data_Foldable = PS["Data.Foldable"];     
  var newTask = function (taskId) {
      return function (description) {
          return {
              taskId: taskId, 
              description: description, 
              completed: false, 
              editing: false
          };
      };
  };
  var initialAppState = {
      inputVal: "", 
      todos: Data_StrMap.empty, 
      lastUid: 0, 
      filter: ""
  };
  var handleAction = function (action) {
      return function (state) {
          if (action instanceof Action.NoOp) {
              return state;
          };
          if (action instanceof Action.Add) {
              var uid = state.lastUid + 1 | 0;
              var newTodos = Data_StrMap.insert(Prelude.show(Prelude.showInt)(uid))(newTask(uid)(action.value0))(state.todos);
              var _2 = {};
              for (var _3 in state) {
                  if (state.hasOwnProperty(_3)) {
                      _2[_3] = state[_3];
                  };
              };
              _2.lastUid = uid;
              _2.todos = newTodos;
              _2.inputVal = "";
              return _2;
          };
          if (action instanceof Action.Check) {
              var changeTodo = function (t) {
                  return Data_Maybe.Just.create((function () {
                      var _5 = {};
                      for (var _6 in t) {
                          if (t.hasOwnProperty(_6)) {
                              _5[_6] = t[_6];
                          };
                      };
                      _5.completed = action.value1;
                      return _5;
                  })());
              };
              var newTodos = Data_StrMap.update(changeTodo)(Prelude.show(Prelude.showInt)(action.value0))(state.todos);
              var _7 = {};
              for (var _8 in state) {
                  if (state.hasOwnProperty(_8)) {
                      _7[_8] = state[_8];
                  };
              };
              _7.todos = newTodos;
              return _7;
          };
          if (action instanceof Action.Delete) {
              var newTodos = Data_StrMap["delete"](Prelude.show(Prelude.showInt)(action.value0))(state.todos);
              var _11 = {};
              for (var _12 in state) {
                  if (state.hasOwnProperty(_12)) {
                      _11[_12] = state[_12];
                  };
              };
              _11.todos = newTodos;
              return _11;
          };
          if (action instanceof Action.ChangedInput) {
              var _14 = {};
              for (var _15 in state) {
                  if (state.hasOwnProperty(_15)) {
                      _14[_15] = state[_15];
                  };
              };
              _14.inputVal = action.value0;
              return _14;
          };
          if (action instanceof Action.DeleteCompleted) {
              var changeTodo = function (t) {
                  if (t.completed) {
                      return Data_Maybe.Nothing.value;
                  };
                  if (!t.completed) {
                      return new Data_Maybe.Just(t);
                  };
                  throw new Error("Failed pattern match at Store line 65, column 17 - line 66, column 13: " + [ t.completed.constructor.name ]);
              };
              var newTodos = Data_Foldable.foldl(Data_Foldable.foldableArray)(Prelude.flip(Data_StrMap.update(changeTodo)))(state.todos)(Data_StrMap.keys(state.todos));
              var _18 = {};
              for (var _19 in state) {
                  if (state.hasOwnProperty(_19)) {
                      _18[_19] = state[_19];
                  };
              };
              _18.todos = newTodos;
              return _18;
          };
          if (action instanceof Action.Edit) {
              var changeTodo = function (t) {
                  return Data_Maybe.Just.create((function () {
                      var _20 = {};
                      for (var _21 in t) {
                          if (t.hasOwnProperty(_21)) {
                              _20[_21] = t[_21];
                          };
                      };
                      _20.editing = action.value1;
                      return _20;
                  })());
              };
              var newTodos = Data_StrMap.update(changeTodo)(Prelude.show(Prelude.showInt)(action.value0))(state.todos);
              var _22 = {};
              for (var _23 in state) {
                  if (state.hasOwnProperty(_23)) {
                      _22[_23] = state[_23];
                  };
              };
              _22.todos = newTodos;
              return _22;
          };
          if (action instanceof Action.ChangeDescription) {
              var changeTodo = function (t) {
                  return Data_Maybe.Just.create((function () {
                      var _26 = {};
                      for (var _27 in t) {
                          if (t.hasOwnProperty(_27)) {
                              _26[_27] = t[_27];
                          };
                      };
                      _26.description = action.value1;
                      return _26;
                  })());
              };
              var newTodos = Data_StrMap.update(changeTodo)(Prelude.show(Prelude.showInt)(action.value0))(state.todos);
              var _28 = {};
              for (var _29 in state) {
                  if (state.hasOwnProperty(_29)) {
                      _28[_29] = state[_29];
                  };
              };
              _28.todos = newTodos;
              return _28;
          };
          if (action instanceof Action.ChangeFilter) {
              var _32 = {};
              for (var _33 in state) {
                  if (state.hasOwnProperty(_33)) {
                      _32[_33] = state[_33];
                  };
              };
              _32.filter = action.value0;
              return _32;
          };
          throw new Error("Failed pattern match at Store line 42, column 1 - line 43, column 1: " + [ action.constructor.name ]);
      };
  };
  exports["handleAction"] = handleAction;
  exports["initialAppState"] = initialAppState;;
 
})(PS["Store"] = PS["Store"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Signal_Channel = PS["Signal.Channel"];
  var Prelude = PS["Prelude"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Action = PS["Action"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_List = PS["Data.List"];
  var Store = PS["Store"];
  var Data_Foldable = PS["Data.Foldable"];     
  var taskEditableLabel = function (chan) {
      return function (task) {
          if (task.editing) {
              return Incremental_Elements.input([ Incremental_Attributes["type'"]("text"), Incremental_Attributes.value(task.description), Incremental_Attributes["class'"]("task-description"), Incremental_Attributes["onInput'"](function (_3) {
                  return Signal_Channel.send(chan)(Action.ChangeDescription.create(task.taskId)(Incremental_Attributes.targetValue(_3)));
              }), Incremental_Attributes.onBlur(Signal_Channel.send(chan)(new Action.Edit(task.taskId, false))) ])(Incremental_DOM.iempty);
          };
          if (Prelude.otherwise) {
              return Incremental_Elements.label([ Incremental_Attributes["class'"]("task-label"), Incremental_Attributes.onDoubleClick(Signal_Channel.send(chan)(new Action.Edit(task.taskId, true))) ])(Incremental_DOM.text(task.description));
          };
          throw new Error("Failed pattern match at Components.TaskList line 25, column 1 - line 26, column 1: " + [ chan.constructor.name, task.constructor.name ]);
      };
  };
  var taskItem = function (chan) {
      return function (task) {
          return Incremental_Elements.li([ Incremental_Attributes.key(Prelude.show(Prelude.showInt)(task.taskId)), Incremental_Attributes["class'"]("task-item") ])(function __do() {
              Incremental_Elements.input([ Incremental_Attributes["type'"]("checkbox"), Incremental_Attributes.checked(task.completed), Incremental_Attributes.onClick(Signal_Channel.send(chan)(new Action.Check(task.taskId, !task.completed))) ])(Incremental_DOM.iempty)();
              taskEditableLabel(chan)(task)();
              return Incremental_Elements["span'"]([ Incremental_Attributes.onClick(Signal_Channel.send(chan)(new Action.Delete(task.taskId))) ])(Incremental_DOM.text("\xd7"))();
          });
      };
  };
  var taskList = function (chan) {
      return function (tasks) {
          return Incremental_Elements.ul([ Incremental_Attributes["class'"]("task-list") ])(Data_Foldable.traverse_(Control_Monad_Eff.applicativeEff)(Data_List.foldableList)(taskItem(chan))(tasks));
      };
  };
  exports["taskList"] = taskList;;
 
})(PS["Components.TaskList"] = PS["Components.TaskList"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports.className = function (node) {
    return function () {
      return node.className;
    };
  };

  exports.setClassName = function (className) {
    return function (node) {
      return function () {
        node.className = className;
        return {};
      };
    };
  };
 
})(PS["DOM.Node.Element"] = PS["DOM.Node.Element"] || {});
(function(exports) {
  /* global exports */
  "use strict";          

  exports.nullable = function(a, r, f) {
      return a == null ? r : f(a);
  }; 
 
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Data.Nullable"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Function = PS["Data.Function"];                              
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;;
 
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["DOM.Node.Element"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Nullable = PS["Data.Nullable"];
  var DOM = PS["DOM"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  exports["setClassName"] = $foreign.setClassName;;
 
})(PS["DOM.Node.Element"] = PS["DOM.Node.Element"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Prelude = PS["Prelude"];     
  var $greater$eq$greater = function (__dict_Bind_0) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return Prelude[">>="](__dict_Bind_0)(f(a))(g);
              };
          };
      };
  };
  exports[">=>"] = $greater$eq$greater;;
 
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Signal_Channel = PS["Signal.Channel"];
  var Prelude = PS["Prelude"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Action = PS["Action"];
  var Store = PS["Store"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_List = PS["Data.List"];
  var DOM_Node_Element = PS["DOM.Node.Element"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var DOM = PS["DOM"];
  var Control_Bind = PS["Control.Bind"];     
  var taskListFooter = function (chan) {
      return function (tasks) {
          var completedTasks = Data_List.filter(function (t) {
              return t.completed;
          })(tasks);
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("task-list-footer") ])(function __do() {
              Incremental_Elements.button([ Incremental_Attributes["type'"]("button"), Incremental_Attributes.onClick(Signal_Channel.send(chan)(Action.DeleteCompleted.value)) ])(Incremental_DOM.text("Remove completed"))();
              return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("task-stats") ])(function __do() {
                  Control_Bind[">=>"](Control_Monad_Eff.bindEff)(Incremental_Elements["span'"]([ Incremental_Attributes["class'"]("total") ]))(DOM_Node_Element.setClassName("dom-manipulation"))(Incremental_DOM.text("Total: " + Prelude.show(Prelude.showInt)(Data_List.length(tasks))))();
                  return Incremental_Elements["span'"]([ Incremental_Attributes["class'"]("completed") ])(Incremental_DOM.text("Completed: " + Prelude.show(Prelude.showInt)(Data_List.length(completedTasks))))();
              })();
          });
      };
  };
  exports["taskListFooter"] = taskListFooter;;
 
})(PS["Components.TaskListFooter"] = PS["Components.TaskListFooter"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Prelude = PS["Prelude"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Signal_Channel = PS["Signal.Channel"];
  var Signal = PS["Signal"];
  var Action = PS["Action"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];     
  var todoFilter = function (chan) {
      return function (filterStr) {
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("todo-filter") ])(Incremental_Elements.input([ Incremental_Attributes.placeholder("Enter filter"), Incremental_Attributes.value(filterStr), Incremental_Attributes["type'"]("text"), Incremental_Attributes["onInput'"](function (_2) {
              return Signal_Channel.send(chan)(Action.ChangeFilter.create(Incremental_Attributes.targetValue(_2)));
          }) ])(Incremental_DOM.iempty));
      };
  };
  exports["todoFilter"] = todoFilter;;
 
})(PS["Components.TodoFilter"] = PS["Components.TodoFilter"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports._indexOf = function (just) {
    return function (nothing) {
      return function (x) {
        return function (s) {
          var i = s.indexOf(x);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };

  exports.length = function (s) {
    return s.length;
  };
 
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Data.String"];
  var Prelude = PS["Prelude"];
  var Data_Char = PS["Data.Char"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_String_Unsafe = PS["Data.String.Unsafe"];                                          
  var indexOf = $foreign._indexOf(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var contains = function (x) {
      return function (s) {
          return Data_Maybe.isJust(indexOf(x)(s));
      };
  };
  exports["indexOf"] = indexOf;
  exports["contains"] = contains;
  exports["length"] = $foreign.length;;
 
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Signal_Channel = PS["Signal.Channel"];
  var Prelude = PS["Prelude"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Action = PS["Action"];
  var Store = PS["Store"];
  var Data_List = PS["Data.List"];
  var Data_StrMap = PS["Data.StrMap"];
  var Data_String = PS["Data.String"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM = PS["DOM"];
  var Components_TaskAdder = PS["Components.TaskAdder"];
  var Components_TaskList = PS["Components.TaskList"];
  var Components_TaskListFooter = PS["Components.TaskListFooter"];
  var Components_TodoFilter = PS["Components.TodoFilter"];     
  var todoList = function (chan) {
      return function (state) {
          var tasksAsList = Data_StrMap.values(state.todos);
          var filteredTasks = (function () {
              if (Data_String.length(state.filter) > 0) {
                  return Data_List.filter(function (t) {
                      return Data_String.contains(state.filter)(t.description);
                  })(tasksAsList);
              };
              if (Prelude.otherwise) {
                  return tasksAsList;
              };
              throw new Error("Failed pattern match at Components.TodoList line 21, column 1 - line 22, column 1: " + [  ]);
          })();
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("todo-list") ])(function __do() {
              Components_TaskAdder.taskAdder(chan)(state.inputVal)();
              Components_TodoFilter.todoFilter(chan)(state.filter)();
              Components_TaskList.taskList(chan)(filteredTasks)();
              return Components_TaskListFooter.taskListFooter(chan)(tasksAsList)();
          });
      };
  };
  exports["todoList"] = todoList;;
 
})(PS["Components.TodoList"] = PS["Components.TodoList"] || {});
(function(exports) {
  /* global exports, window */
  "use strict";

  // module DOM.HTML

  exports.window = function () {
    return window;
  };
 
})(PS["DOM.HTML"] = PS["DOM.HTML"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["DOM.HTML.Types"];
  var Prelude = PS["Prelude"];
  var Data_Either = PS["Data.Either"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Foreign_Class = PS["Data.Foreign.Class"];
  var DOM_Event_Types = PS["DOM.Event.Types"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];                  
  var htmlElementToElement = Unsafe_Coerce.unsafeCoerce;
  exports["htmlElementToElement"] = htmlElementToElement;;
 
})(PS["DOM.HTML.Types"] = PS["DOM.HTML.Types"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["DOM.HTML"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  exports["window"] = $foreign.window;;
 
})(PS["DOM.HTML"] = PS["DOM.HTML"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module DOM.HTML.Document

  exports.body = function (doc) {
    return function () {
      return doc.body;
    };
  };
 
})(PS["DOM.HTML.Document"] = PS["DOM.HTML.Document"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["DOM.HTML.Document"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Nullable = PS["Data.Nullable"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  exports["body"] = $foreign.body;;
 
})(PS["DOM.HTML.Document"] = PS["DOM.HTML.Document"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module DOM.HTML.Window

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };
 
})(PS["DOM.HTML.Window"] = PS["DOM.HTML.Window"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["DOM.HTML.Window"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  exports["document"] = $foreign.document;;
 
})(PS["DOM.HTML.Window"] = PS["DOM.HTML.Window"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Data.Maybe.Unsafe

  exports.unsafeThrow = function (msg) {
    throw new Error(msg);
  };
 
})(PS["Data.Maybe.Unsafe"] = PS["Data.Maybe.Unsafe"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var $foreign = PS["Data.Maybe.Unsafe"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];     
  var fromJust = function (_206) {
      if (_206 instanceof Data_Maybe.Just) {
          return _206.value0;
      };
      if (_206 instanceof Data_Maybe.Nothing) {
          return $foreign.unsafeThrow("Data.Maybe.Unsafe.fromJust called on Nothing");
      };
      throw new Error("Failed pattern match at Data.Maybe.Unsafe line 10, column 1 - line 11, column 1: " + [ _206.constructor.name ]);
  };
  exports["fromJust"] = fromJust;;
 
})(PS["Data.Maybe.Unsafe"] = PS["Data.Maybe.Unsafe"] || {});
(function(exports) {
  // Generated by psc version 0.7.4.1
  "use strict";
  var Data_Maybe_Unsafe = PS["Data.Maybe.Unsafe"];
  var Data_Nullable = PS["Data.Nullable"];
  var DOM_HTML = PS["DOM.HTML"];
  var DOM_HTML_Window = PS["DOM.HTML.Window"];
  var DOM_HTML_Document = PS["DOM.HTML.Document"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  var DOM = PS["DOM"];
  var Signal = PS["Signal"];
  var Signal_Channel = PS["Signal.Channel"];
  var Action = PS["Action"];
  var Store = PS["Store"];
  var Components_TodoList = PS["Components.TodoList"];     
  var body = Prelude["<$>"](Control_Monad_Eff.functorEff)(Prelude["<$>"](Prelude.functorFn)(Prelude["<$>"](Prelude.functorFn)(DOM_HTML_Types.htmlElementToElement)(Data_Maybe_Unsafe.fromJust))(Data_Nullable.toMaybe))(Prelude[">>="](Control_Monad_Eff.bindEff)(Prelude[">>="](Control_Monad_Eff.bindEff)(DOM_HTML.window)(DOM_HTML_Window.document))(DOM_HTML_Document.body));
  var renderAction = function (chan) {
      return function (action) {
          return Signal.runSignal(Signal["~>"](Signal.functorSignal)(Signal["~>"](Signal.functorSignal)(Signal["~>"](Signal.functorSignal)(Signal.foldp(Store.handleAction)(Store.initialAppState)(action))(Components_TodoList.todoList(chan)))(Incremental_DOM.patch))(Prelude.bind(Control_Monad_Eff.bindEff)(body)));
      };
  };
  var main = function __do() {
      var _0 = Signal_Channel.channel(Action.NoOp.value)();
      return renderAction(_0)(Signal_Channel.subscribe(_0))();
  };
  exports["main"] = main;
  exports["renderAction"] = renderAction;
  exports["body"] = body;;
 
})(PS["Main"] = PS["Main"] || {});

PS["Main"].main();

},{"incremental-dom":2}],2:[function(require,module,exports){
(function (process){

/**
 * @license
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** */
exports.notifications = {
  /**
   * Called after patch has compleated with any Nodes that have been created
   * and added to the DOM.
   * @type {?function(Array<!Node>)}
   */
  nodesCreated: null,

  /**
   * Called after patch has compleated with any Nodes that have been removed
   * from the DOM.
   * Note it's an applications responsibility to handle any childNodes.
   * @type {?function(Array<!Node>)}
   */
  nodesDeleted: null
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Similar to the built-in Treewalker class, but simplified and allows direct
 * access to modify the currentNode property.
 * @param {!Element|!DocumentFragment} node The root Node of the subtree the
 *     walker should start traversing.
 * @constructor
 */
function TreeWalker(node) {
  /**
   * Keeps track of the current parent node. This is necessary as the traversal
   * methods may traverse past the last child and we still need a way to get
   * back to the parent.
   * @const @private {!Array<!Node>}
   */
  this.stack_ = [];

  /**
   * @const {!Element|!DocumentFragment}
   */
  this.root = node;

  /**
   * @type {?Node}
   */
  this.currentNode = node;
}

/**
 * @return {!Node} The current parent of the current location in the subtree.
 */
TreeWalker.prototype.getCurrentParent = function () {
  return this.stack_[this.stack_.length - 1];
};

/**
 * Changes the current location the firstChild of the current location.
 */
TreeWalker.prototype.firstChild = function () {
  this.stack_.push(this.currentNode);
  this.currentNode = this.currentNode.firstChild;
};

/**
 * Changes the current location the nextSibling of the current location.
 */
TreeWalker.prototype.nextSibling = function () {
  this.currentNode = this.currentNode.nextSibling;
};

/**
 * Changes the current location the parentNode of the current location.
 */
TreeWalker.prototype.parentNode = function () {
  this.currentNode = this.stack_.pop();
};

/**
 * Keeps track of the state of a patch.
 * @param {!Element|!DocumentFragment} node The root Node of the subtree the
 *     is for.
 * @param {?Context} prevContext The previous context.
 * @constructor
 */
function Context(node, prevContext) {
  /**
   * @const {TreeWalker}
   */
  this.walker = new TreeWalker(node);

  /**
   * @const {Document}
   */
  this.doc = node.ownerDocument;

  /**
   * Keeps track of what namespace to create new Elements in.
   * @private
   * @const {!Array<(string|undefined)>}
   */
  this.nsStack_ = [undefined];

  /**
   * @const {?Context}
   */
  this.prevContext = prevContext;

  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.created = exports.notifications.nodesCreated && [];

  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.deleted = exports.notifications.nodesDeleted && [];
}

/**
 * @return {(string|undefined)} The current namespace to create Elements in.
 */
Context.prototype.getCurrentNamespace = function () {
  return this.nsStack_[this.nsStack_.length - 1];
};

/**
 * @param {string=} namespace The namespace to enter.
 */
Context.prototype.enterNamespace = function (namespace) {
  this.nsStack_.push(namespace);
};

/**
 * Exits the current namespace
 */
Context.prototype.exitNamespace = function () {
  this.nsStack_.pop();
};

/**
 * @param {!Node} node
 */
Context.prototype.markCreated = function (node) {
  if (this.created) {
    this.created.push(node);
  }
};

/**
 * @param {!Node} node
 */
Context.prototype.markDeleted = function (node) {
  if (this.deleted) {
    this.deleted.push(node);
  }
};

/**
 * Notifies about nodes that were created during the patch opearation.
 */
Context.prototype.notifyChanges = function () {
  if (this.created && this.created.length > 0) {
    exports.notifications.nodesCreated(this.created);
  }

  if (this.deleted && this.deleted.length > 0) {
    exports.notifications.nodesDeleted(this.deleted);
  }
};

/**
 * The current context.
 * @type {?Context}
 */
var context;

/**
 * Enters a new patch context.
 * @param {!Element|!DocumentFragment} node
 */
var enterContext = function (node) {
  context = new Context(node, context);
};

/**
 * Restores the previous patch context.
 */
var restoreContext = function () {
  context = context.prevContext;
};

/**
 * Gets the current patch context.
 * @return {?Context}
 */
var getContext = function () {
  return context;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A cached reference to the hasOwnProperty function.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * A cached reference to the create function.
 */
var create = Object.create;

/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param {!Object<string, *>} map The map to check.
 * @param {string} property The property to check.
 * @return {boolean} Whether map has property.
 */
var has = function (map, property) {
  return hasOwnProperty.call(map, property);
};

/**
 * Creates an map object without a prototype.
 * @return {!Object}
 */
var createMap = function () {
  return create(null);
};

/**
 * Keeps track of information needed to perform diffs for a given DOM node.
 * @param {!string} nodeName
 * @param {?string=} key
 * @constructor
 */
function NodeData(nodeName, key) {
  /**
   * The attributes and their values.
   * @const
   */
  this.attrs = createMap();

  /**
   * An array of attribute name/value pairs, used for quickly diffing the
   * incomming attributes to see if the DOM node's attributes need to be
   * updated.
   * @const {Array<*>}
   */
  this.attrsArr = [];

  /**
   * The incoming attributes for this Node, before they are updated.
   * @const {!Object<string, *>}
   */
  this.newAttrs = createMap();

  /**
   * The key used to identify this node, used to preserve DOM nodes when they
   * move within their parent.
   * @const
   */
  this.key = key;

  /**
   * Keeps track of children within this node by their key.
   * {?Object<string, !Element>}
   */
  this.keyMap = null;

  /**
   * Whether or not the keyMap is currently valid.
   * {boolean}
   */
  this.keyMapValid = true;

  /**
   * The last child to have been visited within the current pass.
   * @type {?Node}
   */
  this.lastVisitedChild = null;

  /**
   * The node name for this node.
   * @const {string}
   */
  this.nodeName = nodeName;

  /**
   * @type {?string}
   */
  this.text = null;
}

/**
 * Initializes a NodeData object for a Node.
 *
 * @param {Node} node The node to initialize data for.
 * @param {string} nodeName The node name of node.
 * @param {?string=} key The key that identifies the node.
 * @return {!NodeData} The newly initialized data object
 */
var initData = function (node, nodeName, key) {
  var data = new NodeData(nodeName, key);
  node['__incrementalDOMData'] = data;
  return data;
};

/**
 * Retrieves the NodeData object for a Node, creating it if necessary.
 *
 * @param {Node} node The node to retrieve the data for.
 * @return {!NodeData} The NodeData for this Node.
 */
var getData = function (node) {
  var data = node['__incrementalDOMData'];

  if (!data) {
    var nodeName = node.nodeName.toLowerCase();
    var key = null;

    if (node instanceof Element) {
      key = node.getAttribute('key');
    }

    data = initData(node, nodeName, key);
  }

  return data;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.symbols = {
  default: '__default',

  placeholder: '__placeholder'
};

/**
 * Applies an attribute or property to a given Element. If the value is null
 * or undefined, it is removed from the Element. Otherwise, the value is set
 * as an attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {?(boolean|number|string)=} value The attribute's value.
 */
exports.applyAttr = function (el, name, value) {
  if (value == null) {
    el.removeAttribute(name);
  } else {
    el.setAttribute(name, value);
  }
};

/**
 * Applies a property to a given Element.
 * @param {!Element} el
 * @param {string} name The property's name.
 * @param {*} value The property's value.
 */
exports.applyProp = function (el, name, value) {
  el[name] = value;
};

/**
 * Applies a style to an Element. No vendor prefix expansion is done for
 * property names/values.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {string|Object<string,string>} style The style to set. Either a
 *     string of css or an object containing property-value pairs.
 */
var applyStyle = function (el, name, style) {
  if (typeof style === 'string') {
    el.style.cssText = style;
  } else {
    el.style.cssText = '';
    var elStyle = el.style;

    for (var prop in style) {
      if (has(style, prop)) {
        elStyle[prop] = style[prop];
      }
    }
  }
};

/**
 * Updates a single attribute on an Element.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value. If the value is an object or
 *     function it is set on the Element, otherwise, it is set as an HTML
 *     attribute.
 */
var applyAttributeTyped = function (el, name, value) {
  var type = typeof value;

  if (type === 'object' || type === 'function') {
    exports.applyProp(el, name, value);
  } else {
    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
  }
};

/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
var updateAttribute = function (el, name, value) {
  var data = getData(el);
  var attrs = data.attrs;

  if (attrs[name] === value) {
    return;
  }

  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];
  mutator(el, name, value);

  attrs[name] = value;
};

/**
 * A publicly mutable object to provide custom mutators for attributes.
 * @const {!Object<string, function(!Element, string, *)>}
 */
exports.attributes = createMap();

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
exports.attributes[exports.symbols.default] = applyAttributeTyped;

exports.attributes[exports.symbols.placeholder] = function () {};

exports.attributes['style'] = applyStyle;

var SVG_NS = 'http://www.w3.org/2000/svg';

/**
 * Enters a tag, checking to see if it is a namespace boundary, and if so,
 * updates the current namespace.
 * @param {string} tag The tag to enter.
 */
var enterTag = function (tag) {
  if (tag === 'svg') {
    getContext().enterNamespace(SVG_NS);
  } else if (tag === 'foreignObject') {
    getContext().enterNamespace(undefined);
  }
};

/**
 * Exits a tag, checking to see if it is a namespace boundary, and if so,
 * updates the current namespace.
 * @param {string} tag The tag to enter.
 */
var exitTag = function (tag) {
  if (tag === 'svg' || tag === 'foreignObject') {
    getContext().exitNamespace();
  }
};

/**
 * Gets the namespace to create an element (of a given tag) in.
 * @param {string} tag The tag to get the namespace for.
 * @return {(string|undefined)} The namespace to create the tag in.
 */
var getNamespaceForTag = function (tag) {
  if (tag === 'svg') {
    return SVG_NS;
  }

  return getContext().getCurrentNamespace();
};

/**
 * Creates an Element.
 * @param {Document} doc The document with which to create the Element.
 * @param {string} tag The tag for the Element.
 * @param {?string=} key A key to identify the Element.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of
 *     the static attributes for the Element.
 * @return {!Element}
 */
var createElement = function (doc, tag, key, statics) {
  var namespace = getNamespaceForTag(tag);
  var el;

  if (namespace) {
    el = doc.createElementNS(namespace, tag);
  } else {
    el = doc.createElement(tag);
  }

  initData(el, tag, key);

  if (statics) {
    for (var i = 0; i < statics.length; i += 2) {
      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);
    }
  }

  return el;
};

/**
 * Creates a Node, either a Text or an Element depending on the node name
 * provided.
 * @param {Document} doc The document with which to create the Node.
 * @param {string} nodeName The tag if creating an element or #text to create
 *     a Text.
 * @param {?string=} key A key to identify the Element.
 * @param {?Array<*>=} statics The static data to initialize the Node
 *     with. For an Element, an array of attribute name/value pairs of
 *     the static attributes for the Element.
 * @return {!Node}
 */
var createNode = function (doc, nodeName, key, statics) {
  if (nodeName === '#text') {
    return doc.createTextNode('');
  }

  return createElement(doc, nodeName, key, statics);
};

/**
 * Creates a mapping that can be used to look up children using a key.
 * @param {!Node} el
 * @return {!Object<string, !Element>} A mapping of keys to the children of the
 *     Element.
 */
var createKeyMap = function (el) {
  var map = createMap();
  var children = el.children;
  var count = children.length;

  for (var i = 0; i < count; i += 1) {
    var child = children[i];
    var key = getData(child).key;

    if (key) {
      map[key] = child;
    }
  }

  return map;
};

/**
 * Retrieves the mapping of key to child node for a given Element, creating it
 * if necessary.
 * @param {!Node} el
 * @return {!Object<string, !Node>} A mapping of keys to child Elements
 */
var getKeyMap = function (el) {
  var data = getData(el);

  if (!data.keyMap) {
    data.keyMap = createKeyMap(el);
  }

  return data.keyMap;
};

/**
 * Retrieves a child from the parent with the given key.
 * @param {!Node} parent
 * @param {?string=} key
 * @return {?Element} The child corresponding to the key.
 */
var getChild = function (parent, key) {
  return (/** @type {?Element} */key && getKeyMap(parent)[key]
  );
};

/**
 * Registers an element as being a child. The parent will keep track of the
 * child using the key. The child can be retrieved using the same key using
 * getKeyMap. The provided key should be unique within the parent Element.
 * @param {!Node} parent The parent of child.
 * @param {string} key A key to identify the child with.
 * @param {!Node} child The child to register.
 */
var registerChild = function (parent, key, child) {
  getKeyMap(parent)[key] = child;
};

if (process.env.NODE_ENV !== 'production') {
  /**
  * Makes sure that keyed Element matches the tag name provided.
  * @param {!Element} node The node that is being matched.
  * @param {string=} tag The tag name of the Element.
  * @param {?string=} key The key of the Element.
  */
  var assertKeyedTagMatches = function (node, tag, key) {
    var nodeName = getData(node).nodeName;
    if (nodeName !== tag) {
      throw new Error('Was expecting node with key "' + key + '" to be a ' + tag + ', not a ' + nodeName + '.');
    }
  };
}

/**
 * Checks whether or not a given node matches the specified nodeName and key.
 *
 * @param {!Node} node An HTML node, typically an HTMLElement or Text.
 * @param {?string} nodeName The nodeName for this node.
 * @param {?string=} key An optional key that identifies a node.
 * @return {boolean} True if the node matches, false otherwise.
 */
var matches = function (node, nodeName, key) {
  var data = getData(node);

  // Key check is done using double equals as we want to treat a null key the
  // same as undefined. This should be okay as the only values allowed are
  // strings, null and undefined so the == semantics are not too weird.
  return key == data.key && nodeName === data.nodeName;
};

/**
 * Aligns the virtual Element definition with the actual DOM, moving the
 * corresponding DOM node to the correct location or creating it if necessary.
 * @param {string} nodeName For an Element, this should be a valid tag string.
 *     For a Text, this should be #text.
 * @param {?string=} key The key used to identify this element.
 * @param {?Array<*>=} statics For an Element, this should be an array of
 *     name-value pairs.
 * @return {!Node} The matching node.
 */
var alignWithDOM = function (nodeName, key, statics) {
  var context = getContext();
  var walker = context.walker;
  var currentNode = walker.currentNode;
  var parent = walker.getCurrentParent();
  var matchingNode;

  // Check to see if we have a node to reuse
  if (currentNode && matches(currentNode, nodeName, key)) {
    matchingNode = currentNode;
  } else {
    var existingNode = getChild(parent, key);

    // Check to see if the node has moved within the parent or if a new one
    // should be created
    if (existingNode) {
      if (process.env.NODE_ENV !== 'production') {
        assertKeyedTagMatches(existingNode, nodeName, key);
      }

      matchingNode = existingNode;
    } else {
      matchingNode = createNode(context.doc, nodeName, key, statics);

      if (key) {
        registerChild(parent, key, matchingNode);
      }

      context.markCreated(matchingNode);
    }

    // If the node has a key, remove it from the DOM to prevent a large number
    // of re-orders in the case that it moved far or was completely removed.
    // Since we hold on to a reference through the keyMap, we can always add it
    // back.
    if (currentNode && getData(currentNode).key) {
      parent.replaceChild(matchingNode, currentNode);
      getData(parent).keyMapValid = false;
    } else {
      parent.insertBefore(matchingNode, currentNode);
    }

    walker.currentNode = matchingNode;
  }

  return matchingNode;
};

/**
 * Clears out any unvisited Nodes, as the corresponding virtual element
 * functions were never called for them.
 * @param {Node} node
 */
var clearUnvisitedDOM = function (node) {
  var context = getContext();
  var walker = context.walker;
  var data = getData(node);
  var keyMap = data.keyMap;
  var keyMapValid = data.keyMapValid;
  var lastVisitedChild = data.lastVisitedChild;
  var child = node.lastChild;
  var key;

  data.lastVisitedChild = null;

  if (child === lastVisitedChild && keyMapValid) {
    return;
  }

  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {
    return;
  }

  while (child !== lastVisitedChild) {
    node.removeChild(child);
    context.markDeleted( /** @type {!Node}*/child);

    key = getData(child).key;
    if (key) {
      delete keyMap[key];
    }
    child = node.lastChild;
  }

  // Clean the keyMap, removing any unusued keys.
  for (key in keyMap) {
    child = keyMap[key];
    if (!child.parentNode) {
      context.markDeleted(child);
      delete keyMap[key];
    }
  }

  data.keyMapValid = true;
};

/**
 * Enters an Element, setting the current namespace for nested elements.
 * @param {Node} node
 */
var enterNode = function (node) {
  var data = getData(node);
  enterTag(data.nodeName);
};

/**
 * Exits an Element, unwinding the current namespace to the previous value.
 * @param {Node} node
 */
var exitNode = function (node) {
  var data = getData(node);
  exitTag(data.nodeName);
};

/**
 * Marks node's parent as having visited node.
 * @param {Node} node
 */
var markVisited = function (node) {
  var context = getContext();
  var walker = context.walker;
  var parent = walker.getCurrentParent();
  var data = getData(parent);
  data.lastVisitedChild = node;
};

/**
 * Changes to the first child of the current node.
 */
var firstChild = function () {
  var context = getContext();
  var walker = context.walker;
  enterNode(walker.currentNode);
  walker.firstChild();
};

/**
 * Changes to the next sibling of the current node.
 */
var nextSibling = function () {
  var context = getContext();
  var walker = context.walker;
  markVisited(walker.currentNode);
  walker.nextSibling();
};

/**
 * Changes to the parent of the current node, removing any unvisited children.
 */
var parentNode = function () {
  var context = getContext();
  var walker = context.walker;
  walker.parentNode();
  exitNode(walker.currentNode);
};

if (process.env.NODE_ENV !== 'production') {
  var assertNoUnclosedTags = function (root) {
    var openElement = getContext().walker.getCurrentParent();
    if (!openElement) {
      return;
    }

    var openTags = [];
    while (openElement && openElement !== root) {
      openTags.push(openElement.nodeName.toLowerCase());
      openElement = openElement.parentNode;
    }

    throw new Error('One or more tags were not closed:\n' + openTags.join('\n'));
  };
}

/**
 * Patches the document starting at el with the provided function. This function
 * may be called during an existing patch operation.
 * @param {!Element|!DocumentFragment} node The Element or Document
 *     to patch.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @template T
 */
exports.patch = function (node, fn, data) {
  enterContext(node);

  firstChild();
  fn(data);
  parentNode();
  clearUnvisitedDOM(node);

  if (process.env.NODE_ENV !== 'production') {
    assertNoUnclosedTags(node);
  }

  getContext().notifyChanges();
  restoreContext();
};

/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
var ATTRIBUTES_OFFSET = 3;

/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {Array<*>}
 */
var argsBuilder = [];

if (process.env.NODE_ENV !== 'production') {
  /**
   * Keeps track whether or not we are in an attributes declaration (after
   * elementOpenStart, but before elementOpenEnd).
   * @type {boolean}
   */
  var inAttributes = false;

  /** Makes sure that the caller is not where attributes are expected. */
  var assertNotInAttributes = function () {
    if (inAttributes) {
      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');
    }
  };

  /** Makes sure that the caller is where attributes are expected. */
  var assertInAttributes = function () {
    if (!inAttributes) {
      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');
    }
  };

  /**
   * Makes sure that placeholders have a key specified. Otherwise, conditional
   * placeholders and conditional elements next to placeholders will cause
   * placeholder elements to be re-used as non-placeholders and vice versa.
   * @param {string} key
   */
  var assertPlaceholderKeySpecified = function (key) {
    if (!key) {
      throw new Error('Placeholder elements must have a key specified.');
    }
  };

  /**
   * Makes sure that tags are correctly nested.
   * @param {string} tag
   */
  var assertCloseMatchesOpenTag = function (tag) {
    var context = getContext();
    var walker = context.walker;
    var closingNode = walker.getCurrentParent();
    var data = getData(closingNode);

    if (tag !== data.nodeName) {
      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');
    }
  };

  /** Updates the state to being in an attribute declaration. */
  var setInAttributes = function () {
    inAttributes = true;
  };

  /** Updates the state to not being in an attribute declaration. */
  var setNotInAttributes = function () {
    inAttributes = false;
  };
}

/**
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
exports.elementOpen = function (tag, key, statics, var_args) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
  }

  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);
  var data = getData(node);

  /*
   * Checks to see if one or more attributes have changed for a given Element.
   * When no attributes have changed, this is much faster than checking each
   * individual argument. When attributes have changed, the overhead of this is
   * minimal.
   */
  var attrsArr = data.attrsArr;
  var attrsChanged = false;
  var i = ATTRIBUTES_OFFSET;
  var j = 0;

  for (; i < arguments.length; i += 1, j += 1) {
    if (attrsArr[j] !== arguments[i]) {
      attrsChanged = true;
      break;
    }
  }

  for (; i < arguments.length; i += 1, j += 1) {
    attrsArr[j] = arguments[i];
  }

  if (j < attrsArr.length) {
    attrsChanged = true;
    attrsArr.length = j;
  }

  /*
   * Actually perform the attribute update.
   */
  if (attrsChanged) {
    var attr,
        newAttrs = data.newAttrs;

    for (attr in newAttrs) {
      newAttrs[attr] = undefined;
    }

    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {
      newAttrs[arguments[i]] = arguments[i + 1];
    }

    for (attr in newAttrs) {
      updateAttribute(node, attr, newAttrs[attr]);
    }
  }

  firstChild();
  return node;
};

/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 */
exports.elementOpenStart = function (tag, key, statics) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
    setInAttributes();
  }

  argsBuilder[0] = tag;
  argsBuilder[1] = key;
  argsBuilder[2] = statics;
};

/***
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name
 * @param {*} value
 */
exports.attr = function (name, value) {
  if (process.env.NODE_ENV !== 'production') {
    assertInAttributes();
  }

  argsBuilder.push(name, value);
};

/**
 * Closes an open tag started with elementOpenStart.
 * @return {!Element} The corresponding Element.
 */
exports.elementOpenEnd = function () {
  if (process.env.NODE_ENV !== 'production') {
    assertInAttributes();
    setNotInAttributes();
  }

  var node = exports.elementOpen.apply(null, argsBuilder);
  argsBuilder.length = 0;
  return node;
};

/**
 * Closes an open virtual Element.
 *
 * @param {string} tag The element's tag.
 * @return {!Element} The corresponding Element.
 */
exports.elementClose = function (tag) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
    assertCloseMatchesOpenTag(tag);
  }

  parentNode();

  var node = /** @type {!Element} */getContext().walker.currentNode;

  clearUnvisitedDOM(node);

  nextSibling();
  return node;
};

/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
exports.elementVoid = function (tag, key, statics, var_args) {
  var node = exports.elementOpen.apply(null, arguments);
  exports.elementClose.apply(null, arguments);
  return node;
};

/**
 * Declares a virtual Element at the current location in the document that is a
 * placeholder element. Children of this Element can be manually managed and
 * will not be cleared by the library.
 *
 * A key must be specified to make sure that this node is correctly preserved
 * across all conditionals.
 *
 * @param {string} tag The element's tag.
 * @param {string} key The key used to identify this element.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
exports.elementPlaceholder = function (tag, key, statics, var_args) {
  if (process.env.NODE_ENV !== 'production') {
    assertPlaceholderKeySpecified(key);
  }

  var node = exports.elementOpen.apply(null, arguments);
  updateAttribute(node, exports.symbols.placeholder, true);
  exports.elementClose.apply(null, arguments);
  return node;
};

/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} var_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 * @return {!Text} The corresponding text node.
 */
exports.text = function (value, var_args) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
  }

  var node = /** @type {!Text}*/alignWithDOM('#text', null);
  var data = getData(node);

  if (data.text !== value) {
    data.text = /** @type {string} */value;

    var formatted = value;
    for (var i = 1; i < arguments.length; i += 1) {
      formatted = arguments[i](formatted);
    }

    node.data = formatted;
  }

  nextSibling();
  return node;
};

}).call(this,require('_process'))
},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1]);
