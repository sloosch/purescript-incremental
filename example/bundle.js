(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by psc-bundle 0.7.0.0
var PS = { };
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var NoOp = (function () {
      function NoOp() {

      };
      NoOp.value = new NoOp();
      return NoOp;
  })();
  var Add = (function () {
      function Add(value0) {
          this.value0 = value0;
      };
      Add.create = function (value0) {
          return new Add(value0);
      };
      return Add;
  })();
  var Delete = (function () {
      function Delete(value0) {
          this.value0 = value0;
      };
      Delete.create = function (value0) {
          return new Delete(value0);
      };
      return Delete;
  })();
  var Check = (function () {
      function Check(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Check.create = function (value0) {
          return function (value1) {
              return new Check(value0, value1);
          };
      };
      return Check;
  })();
  var ChangedInput = (function () {
      function ChangedInput(value0) {
          this.value0 = value0;
      };
      ChangedInput.create = function (value0) {
          return new ChangedInput(value0);
      };
      return ChangedInput;
  })();
  var DeleteCompleted = (function () {
      function DeleteCompleted() {

      };
      DeleteCompleted.value = new DeleteCompleted();
      return DeleteCompleted;
  })();
  var Edit = (function () {
      function Edit(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Edit.create = function (value0) {
          return function (value1) {
              return new Edit(value0, value1);
          };
      };
      return Edit;
  })();
  var ChangeDescription = (function () {
      function ChangeDescription(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ChangeDescription.create = function (value0) {
          return function (value1) {
              return new ChangeDescription(value0, value1);
          };
      };
      return ChangeDescription;
  })();
  var ChangeFilter = (function () {
      function ChangeFilter(value0) {
          this.value0 = value0;
      };
      ChangeFilter.create = function (value0) {
          return new ChangeFilter(value0);
      };
      return ChangeFilter;
  })();
  exports["NoOp"] = NoOp;
  exports["Add"] = Add;
  exports["Delete"] = Delete;
  exports["Check"] = Check;
  exports["ChangedInput"] = ChangedInput;
  exports["DeleteCompleted"] = DeleteCompleted;
  exports["Edit"] = Edit;
  exports["ChangeDescription"] = ChangeDescription;
  exports["ChangeFilter"] = ChangeFilter;;
 
})(PS["Action"] = PS["Action"] || {});
(function(exports) {
  var IDom = require('incremental-dom');

  // module Incremental.DOM

  function unfoldAttributes (attributes) {
      return attributes.reduce(function (attrs, v) {
          var a = v.value0;
          var val = a.value;
          var name = a.name;
          var isStatic = a.static;
          if (name === 'value') {
              val = new String(val);
          }

          if(val === '__UNSET__') {
              //ignore
          } else if (name === 'key') {
              attrs.key = val;
          } else if (isStatic) {
              attrs.statics.push(name);
              attrs.statics.push(val);
          } else {
              attrs.attributes.push(name);
              var valueToPush = val;
              if(typeof valueToPush === 'function') {
                  valueToPush = function(event) {
                      var effect = val(event);
                      effect();
                  };
              }
              attrs.attributes.push(valueToPush);
          }
          return attrs;
      }, {statics : [], key: null, attributes: []});
  }

  exports.element = function (tagName) {
          return function (attrs) {
              return function (children) {
                  return function() {
                      var unfoldedAttrs = unfoldAttributes(attrs);
                      var args = [tagName, unfoldedAttrs.key, unfoldedAttrs.statics].concat(unfoldedAttrs.attributes);
                      IDom.elementOpen.apply(null, args);
                      children.forEach(function (f) {
                          f();
                      });
                      IDom.elementClose(tagName);
                  };
              };
          };
  };

  exports.text = function(text) {
      return function() {
          IDom.text(text);
      };
  };


  exports.patch = function (iRootElement) {
      return function (domElement) {
          return function iDomEffect() {
              IDom.patch(domElement, iRootElement, {});
              return {};
          }
      };
  };
 
})(PS["Incremental.DOM"] = PS["Incremental.DOM"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Prelude

  //- Functor --------------------------------------------------------------------

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };

  //- Semiring -------------------------------------------------------------------

  exports.intAdd = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x + y | 0;
    };
  };

  exports.intMul = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x * y | 0;
    };
  };

  //- Eq -------------------------------------------------------------------------

  exports.refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };

  //- Ord ------------------------------------------------------------------------

  exports.unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x > y ? gt : eq;
          };
        };
      };
    };
  };                                          

  //- BooleanAlgebra -------------------------------------------------------------

  exports.boolOr = function (b1) {
    return function (b2) {
      return b1 || b2;
    };
  };

  exports.boolAnd = function (b1) {
    return function (b2) {
      return b1 && b2;
    };
  };

  exports.boolNot = function (b) {
    return !b;
  };

  //- Show -----------------------------------------------------------------------

  exports.showIntImpl = function (n) {
    return n.toString();
  };
 
})(PS["Prelude"] = PS["Prelude"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Prelude"];
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var Functor = function (map) {
      this.map = map;
  };
  var Apply = function (__superclass_Prelude$dotFunctor_0, apply) {
      this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
      this.apply = apply;
  };
  var Applicative = function (__superclass_Prelude$dotApply_0, pure) {
      this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
      this.pure = pure;
  };
  var Bind = function (__superclass_Prelude$dotApply_0, bind) {
      this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
      this.bind = bind;
  };
  var Monad = function (__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
      this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
      this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
  };
  var Semiring = function (add, mul, one, zero) {
      this.add = add;
      this.mul = mul;
      this.one = one;
      this.zero = zero;
  };
  var Eq = function (eq) {
      this.eq = eq;
  };
  var Ord = function (__superclass_Prelude$dotEq_0, compare) {
      this["__superclass_Prelude.Eq_0"] = __superclass_Prelude$dotEq_0;
      this.compare = compare;
  };
  var Bounded = function (bottom, top) {
      this.bottom = bottom;
      this.top = top;
  };
  var BooleanAlgebra = function (__superclass_Prelude$dotBounded_0, conj, disj, not) {
      this["__superclass_Prelude.Bounded_0"] = __superclass_Prelude$dotBounded_0;
      this.conj = conj;
      this.disj = disj;
      this.not = not;
  };
  var Show = function (show) {
      this.show = show;
  };
  var zero = function (dict) {
      return dict.zero;
  };
  var unsafeCompare = $foreign.unsafeCompareImpl(LT.value)(EQ.value)(GT.value);
  var top = function (dict) {
      return dict.top;
  };                                                 
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };                                                                            
  var semiringInt = new Semiring($foreign.intAdd, $foreign.intMul, 1, 0);
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });                 
  var pure = function (dict) {
      return dict.pure;
  };
  var $$return = function (__dict_Applicative_2) {
      return pure(__dict_Applicative_2);
  };
  var otherwise = true;
  var one = function (dict) {
      return dict.one;
  };
  var not = function (dict) {
      return dict.not;
  };
  var mul = function (dict) {
      return dict.mul;
  };
  var map = function (dict) {
      return dict.map;
  };
  var $less$dollar$greater = function (__dict_Functor_5) {
      return map(__dict_Functor_5);
  };
  var functorArray = new Functor($foreign.arrayMap);
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };                
  var eqInt = new Eq($foreign.refEq);
  var ordInt = new Ord(function () {
      return eqInt;
  }, unsafeCompare);
  var eq = function (dict) {
      return dict.eq;
  };
  var $eq$eq = function (__dict_Eq_7) {
      return eq(__dict_Eq_7);
  };
  var disj = function (dict) {
      return dict.disj;
  };
  var $$const = function (a) {
      return function (_18) {
          return a;
      };
  };
  var conj = function (dict) {
      return dict.conj;
  };
  var compose = function (dict) {
      return dict.compose;
  };
  var functorFn = new Functor(compose(semigroupoidFn));
  var $less$less$less = function (__dict_Semigroupoid_14) {
      return compose(__dict_Semigroupoid_14);
  };
  var compare = function (dict) {
      return dict.compare;
  };
  var $greater = function (__dict_Ord_19) {
      return function (a1) {
          return function (a2) {
              var _368 = compare(__dict_Ord_19)(a1)(a2);
              if (_368 instanceof GT) {
                  return true;
              };
              return false;
          };
      };
  }; 
  var boundedBoolean = new Bounded(false, true);
  var bottom = function (dict) {
      return dict.bottom;
  };
  var booleanAlgebraBoolean = new BooleanAlgebra(function () {
      return boundedBoolean;
  }, $foreign.boolAnd, $foreign.boolOr, $foreign.boolNot);
  var $div$eq = function (__dict_Eq_9) {
      return function (x) {
          return function (y) {
              return not(booleanAlgebraBoolean)($eq$eq(__dict_Eq_9)(x)(y));
          };
      };
  };
  var bind = function (dict) {
      return dict.bind;
  };
  var $greater$greater$eq = function (__dict_Bind_24) {
      return bind(__dict_Bind_24);
  }; 
  var apply = function (dict) {
      return dict.apply;
  };
  var $less$times$greater = function (__dict_Apply_25) {
      return apply(__dict_Apply_25);
  };
  var liftA1 = function (__dict_Applicative_26) {
      return function (f) {
          return function (a) {
              return $less$times$greater(__dict_Applicative_26["__superclass_Prelude.Apply_0"]())(pure(__dict_Applicative_26)(f))(a);
          };
      };
  };
  var ap = function (__dict_Monad_30) {
      return function (f) {
          return function (a) {
              return bind(__dict_Monad_30["__superclass_Prelude.Bind_1"]())(f)(function (_5) {
                  return bind(__dict_Monad_30["__superclass_Prelude.Bind_1"]())(a)(function (_4) {
                      return $$return(__dict_Monad_30["__superclass_Prelude.Applicative_0"]())(_5(_4));
                  });
              });
          };
      };
  }; 
  var add = function (dict) {
      return dict.add;
  };
  var $plus = function (__dict_Semiring_31) {
      return add(__dict_Semiring_31);
  };
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
  exports["Show"] = Show;
  exports["BooleanAlgebra"] = BooleanAlgebra;
  exports["Bounded"] = Bounded;
  exports["Ord"] = Ord;
  exports["Eq"] = Eq;
  exports["Semiring"] = Semiring;
  exports["Monad"] = Monad;
  exports["Bind"] = Bind;
  exports["Applicative"] = Applicative;
  exports["Apply"] = Apply;
  exports["Functor"] = Functor;
  exports["Semigroupoid"] = Semigroupoid;
  exports["show"] = show;
  exports["not"] = not;
  exports["disj"] = disj;
  exports["conj"] = conj;
  exports["bottom"] = bottom;
  exports["top"] = top;
  exports["unsafeCompare"] = unsafeCompare;
  exports[">"] = $greater;
  exports["compare"] = compare;
  exports["/="] = $div$eq;
  exports["=="] = $eq$eq;
  exports["eq"] = eq;
  exports["+"] = $plus;
  exports["one"] = one;
  exports["mul"] = mul;
  exports["zero"] = zero;
  exports["add"] = add;
  exports["ap"] = ap;
  exports[">>="] = $greater$greater$eq;
  exports["bind"] = bind;
  exports["liftA1"] = liftA1;
  exports["pure"] = pure;
  exports["apply"] = apply;
  exports["<$>"] = $less$dollar$greater;
  exports["map"] = map;
  exports["<<<"] = $less$less$less;
  exports["compose"] = compose;
  exports["otherwise"] = otherwise;
  exports["const"] = $$const;
  exports["flip"] = flip;
  exports["semigroupoidFn"] = semigroupoidFn;
  exports["functorFn"] = functorFn;
  exports["functorArray"] = functorArray;
  exports["semiringInt"] = semiringInt;
  exports["eqInt"] = eqInt;
  exports["ordInt"] = ordInt;
  exports["boundedBoolean"] = boundedBoolean;
  exports["booleanAlgebraBoolean"] = booleanAlgebraBoolean;
  exports["showInt"] = showInt;;
 
})(PS["Prelude"] = PS["Prelude"] || {});
(function(exports) {
  //module Incremental.Attributes

  exports.objPropAccessorImpl = function (just) {
      return function (nothing) {
          return function (prop) {
              return function (obj) {
                  if (obj[prop] != null) {
                      return just(obj[prop]);
                  } else {
                      return nothing;
                  }
              };
          };
      };
  };
 
})(PS["Incremental.Attributes"] = PS["Incremental.Attributes"] || {});
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function(x) { return x; }
 
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;;
 
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Extend = PS["Control.Extend"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Monoid = PS["Data.Monoid"];     
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (b) {
      return function (f) {
          return function (_150) {
              if (_150 instanceof Nothing) {
                  return b;
              };
              if (_150 instanceof Just) {
                  return f(_150.value0);
              };
              throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/bower_components/purescript-maybe/src/Data/Maybe.purs line 26, column 1 - line 27, column 1: " + [ b.constructor.name, f.constructor.name, _150.constructor.name ]);
          };
      };
  };                                                   
  var isJust = maybe(false)(Prelude["const"](true));
  var functorMaybe = new Prelude.Functor(function (fn) {
      return function (_152) {
          if (_152 instanceof Just) {
              return new Just(fn(_152.value0));
          };
          return Nothing.value;
      };
  });
  var applyMaybe = new Prelude.Apply(function () {
      return functorMaybe;
  }, function (_153) {
      return function (x) {
          if (_153 instanceof Just) {
              return Prelude["<$>"](functorMaybe)(_153.value0)(x);
          };
          if (_153 instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/bower_components/purescript-maybe/src/Data/Maybe.purs line 121, column 1 - line 145, column 1: " + [ _153.constructor.name, x.constructor.name ]);
      };
  });
  var bindMaybe = new Prelude.Bind(function () {
      return applyMaybe;
  }, function (_155) {
      return function (k) {
          if (_155 instanceof Just) {
              return k(_155.value0);
          };
          if (_155 instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/bower_components/purescript-maybe/src/Data/Maybe.purs line 180, column 1 - line 199, column 1: " + [ _155.constructor.name, k.constructor.name ]);
      };
  });
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["isJust"] = isJust;
  exports["maybe"] = maybe;
  exports["functorMaybe"] = functorMaybe;
  exports["applyMaybe"] = applyMaybe;
  exports["bindMaybe"] = bindMaybe;;
 
})(PS["Data.Maybe"] = PS["Data.Maybe"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Control.Monad.Eff

  exports.returnE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
 
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Control.Monad.Eff"];
  var Prelude = PS["Prelude"];     
  var monadEff = new Prelude.Monad(function () {
      return applicativeEff;
  }, function () {
      return bindEff;
  });
  var bindEff = new Prelude.Bind(function () {
      return applyEff;
  }, $foreign.bindE);
  var applyEff = new Prelude.Apply(function () {
      return functorEff;
  }, Prelude.ap(monadEff));
  var applicativeEff = new Prelude.Applicative(function () {
      return applyEff;
  }, $foreign.returnE);
  var functorEff = new Prelude.Functor(Prelude.liftA1(applicativeEff));
  exports["functorEff"] = functorEff;
  exports["applyEff"] = applyEff;
  exports["applicativeEff"] = applicativeEff;
  exports["bindEff"] = bindEff;
  exports["monadEff"] = monadEff;;
 
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Incremental.Attributes"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var IAttribute = (function () {
      function IAttribute(value0) {
          this.value0 = value0;
      };
      IAttribute.create = function (value0) {
          return new IAttribute(value0);
      };
      return IAttribute;
  })();
  var unsafeObjPropAccessor = $foreign.objPropAccessorImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var toAttributeValue = Unsafe_Coerce.unsafeCoerce;
  var stringAttribute = function (name_1) {
      return function ($$static) {
          return function (value_1) {
              return new IAttribute({
                  name: name_1, 
                  value: toAttributeValue(value_1), 
                  "static": $$static
              });
          };
      };
  };                                          
  var type$prime = stringAttribute("type")(true);
  var value = stringAttribute("value")(false);
  var volatileAttribute = function (name_1) {
      return function (visible) {
          return stringAttribute(name_1)(false)((function () {
              if (visible) {
                  return name_1;
              };
              if (!visible) {
                  return "__UNSET__";
              };
              throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/../src/Incremental/Attributes/Attributes.purs line 71, column 1 - line 72, column 1: " + [ visible.constructor.name ]);
          })());
      };
  };                                           
  var placeholder = stringAttribute("placeholder")(false);
  var orDefault = function (defaultVal) {
      return function (ma) {
          if (ma instanceof Data_Maybe.Just) {
              return ma.value0;
          };
          if (ma instanceof Data_Maybe.Nothing) {
              return defaultVal;
          };
          throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/../src/Incremental/Attributes/Attributes.purs line 205, column 1 - line 206, column 1: " + [ ma.constructor.name ]);
      };
  };
  var targetValue = function (event) {
      return orDefault("")(Prelude.bind(Data_Maybe.bindMaybe)(unsafeObjPropAccessor("target")(event))(function (_11) {
          return unsafeObjPropAccessor("value")(_11);
      }));
  };
  var name = stringAttribute("name")(true);                                                          
  var key = stringAttribute("key")(false); 
  var eventAttribute = function (name_1) {
      return function (handler) {
          return new IAttribute({
              name: name_1, 
              value: toAttributeValue(handler), 
              "static": false
          });
      };
  };
  var on$prime = eventAttribute;
  var on = function (eventName) {
      return function (effect) {
          return on$prime(eventName)(function (_353) {
              return effect;
          });
      };
  };
  var onBlur = on("onblur");    
  var onClick = on("onclick");
  var onDoubleClick = on("ondblclick");         
  var onInput$prime = on$prime("oninput");                                                                                                  
  var class$prime = stringAttribute("class")(false);
  var checked = volatileAttribute("checked");
  exports["targetValue"] = targetValue;
  exports["onBlur"] = onBlur;
  exports["onInput'"] = onInput$prime;
  exports["onDoubleClick"] = onDoubleClick;
  exports["onClick"] = onClick;
  exports["on"] = on;
  exports["placeholder"] = placeholder;
  exports["name"] = name;
  exports["checked"] = checked;
  exports["value"] = value;
  exports["key"] = key;
  exports["type'"] = type$prime;
  exports["class'"] = class$prime;;
 
})(PS["Incremental.Attributes"] = PS["Incremental.Attributes"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  //------------------------------------------------------------------------------
  // Array size ------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.length = function (xs) {
    return xs.length;
  };

  //------------------------------------------------------------------------------
  // Extending arrays ------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.cons = function (e) {
    return function (l) {
      return [e].concat(l);
    };
  };

  exports.concat = function (xss) {
    var result = [];
    for (var i = 0, l = xss.length; i < l; i++) {
      var xs = xss[i];
      for (var j = 0, m = xs.length; j < m; j++) {
        result.push(xs[j]);
      }
    }
    return result;
  };

  exports.filter = function (f) {
    return function (xs) {
      return xs.filter(f);
    };
  };
 
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Data.Maybe.Unsafe

  exports.unsafeThrow = function (msg) {
    throw new Error(msg);
  };
 
})(PS["Data.Maybe.Unsafe"] = PS["Data.Maybe.Unsafe"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Data.Maybe.Unsafe"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];     
  var fromJust = function (_213) {
      if (_213 instanceof Data_Maybe.Just) {
          return _213.value0;
      };
      if (_213 instanceof Data_Maybe.Nothing) {
          return $foreign.unsafeThrow("Data.Maybe.Unsafe.fromJust called on Nothing");
      };
      throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/bower_components/purescript-maybe/src/Data/Maybe/Unsafe.purs line 10, column 1 - line 11, column 1: " + [ _213.constructor.name ]);
  };
  exports["fromJust"] = fromJust;;
 
})(PS["Data.Maybe.Unsafe"] = PS["Data.Maybe.Unsafe"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Data.Array"];
  var Prelude = PS["Prelude"];
  var Data_Traversable = PS["Data.Traversable"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Alt = PS["Control.Alt"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_Unsafe = PS["Data.Maybe.Unsafe"];
  var Data_Foldable = PS["Data.Foldable"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Tuple = PS["Data.Tuple"];     
  var $colon = $foreign.cons;
  exports[":"] = $colon;
  exports["filter"] = $foreign.filter;
  exports["length"] = $foreign.length;;
 
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Incremental.DOM"];
  var Prelude = PS["Prelude"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Data_Array = PS["Data.Array"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  exports["patch"] = $foreign.patch;
  exports["text"] = $foreign.text;
  exports["element"] = $foreign.element;;
 
})(PS["Incremental.DOM"] = PS["Incremental.DOM"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Incremental_DOM = PS["Incremental.DOM"];
  var ul = Incremental_DOM.element("ul");        
  var span$prime = Incremental_DOM.element("span");
  var li = Incremental_DOM.element("li");        
  var label = Incremental_DOM.element("label");
  var input = Incremental_DOM.element("input");
  var div$prime = Incremental_DOM.element("div");
  var button = Incremental_DOM.element("button");
  exports["ul"] = ul;
  exports["span'"] = span$prime;
  exports["li"] = li;
  exports["label"] = label;
  exports["input"] = input;
  exports["div'"] = div$prime;
  exports["button"] = button;;
 
})(PS["Incremental.Elements"] = PS["Incremental.Elements"] || {});
(function(exports) {
  // module Signal.Channel

  exports.channelP =
    function channelP(constant) {
      return function(v) {
        return function() {
          return constant(v);
        };
      };
    };

  exports.sendP =
    function sendP(chan, v) {
      return function(v) {
        return function() {
          chan.set(v);
        };
      };
    };

  exports.subscribe =
    function subscribe(chan) {
      return chan;
    };
 
})(PS["Signal.Channel"] = PS["Signal.Channel"] || {});
(function(exports) {
  // module Signal

  exports.constant =
    function constant(initial) {
      var subs = [];
      var val = initial;
      var sig = {
        subscribe: function(sub) {
          subs.push(sub);
          sub(val);
        },
        get: function() { return val; },
        set: function(newval) {
          val = newval;
          subs.forEach(function(sub) { sub(newval); });
        }
      };
      return sig;
    };

  exports.mapSigP =
    function mapSigP(constant) {
      return function(fun) {
        return function(sig) {
          var out = constant(fun(sig.get()));
          sig.subscribe(function(val) { out.set(fun(val)); });
          return out;
        };
      };
    };

  exports.foldpP =
    function foldpP(constant) {
      return function(fun) {
        return function(seed) {
          return function(sig) {
            var acc = seed;
            var out = constant(acc);
            sig.subscribe(function(val) {
              acc = fun(val)(acc);
              out.set(acc);
            });
            return out;
          };
        };
      };
    };

  exports.runSignal =
    function runSignal(sig) {
      return function() {
        sig.subscribe(function(val) {
          val();
        });
        return {};
      };
    };
 
})(PS["Signal"] = PS["Signal"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Signal"];
  var Data_Foldable = PS["Data.Foldable"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];     
  var $tilde$greater = function (__dict_Functor_0) {
      return Prelude.flip(Prelude["<$>"](__dict_Functor_0));
  };                                                 
  var mapSig = $foreign.mapSigP($foreign.constant);
  var functorSignal = new Prelude.Functor(mapSig);
  var foldp = $foreign.foldpP($foreign.constant);
  exports["~>"] = $tilde$greater;
  exports["foldp"] = foldp;
  exports["functorSignal"] = functorSignal;
  exports["runSignal"] = $foreign.runSignal;
  exports["constant"] = $foreign.constant;;
 
})(PS["Signal"] = PS["Signal"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Signal.Channel"];
  var Signal = PS["Signal"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Prelude = PS["Prelude"];     
  var send = $foreign.sendP;
  var channel = $foreign.channelP(Signal.constant);
  exports["send"] = send;
  exports["channel"] = channel;
  exports["subscribe"] = $foreign.subscribe;;
 
})(PS["Signal.Channel"] = PS["Signal.Channel"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Prelude = PS["Prelude"];
  var Signal_Channel = PS["Signal.Channel"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Action = PS["Action"];     
  var taskAdder = function (chan) {
      return function (val) {
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("task-adder") ])([ Incremental_Elements.input([ Incremental_Attributes["type'"]("text"), Incremental_Attributes.value(val), Incremental_Attributes["onInput'"](Prelude["<<<"](Prelude.semigroupoidFn)(Signal_Channel.send(chan))(Prelude["<<<"](Prelude.semigroupoidFn)(Action.ChangedInput.create)(Incremental_Attributes.targetValue))) ])([  ]), Incremental_Elements.button([ Incremental_Attributes["type'"]("button"), Incremental_Attributes.onClick(Signal_Channel.send(chan)(new Action.Add(val))) ])([ Incremental_DOM.text("Add todo") ]) ]);
      };
  };
  exports["taskAdder"] = taskAdder;;
 
})(PS["Components.TaskAdder"] = PS["Components.TaskAdder"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Array = PS["Data.Array"];
  var Action = PS["Action"];     
  var newTask = function (taskId) {
      return function (description) {
          return {
              taskId: taskId, 
              description: description, 
              completed: false, 
              editing: false
          };
      };
  };
  var initialAppState = {
      inputVal: "", 
      todos: [  ], 
      lastUid: 0, 
      filter: ""
  };
  var handleAction = function (action) {
      return function (state) {
          if (action instanceof Action.NoOp) {
              return state;
          };
          if (action instanceof Action.Add) {
              var uid = Prelude["+"](Prelude.semiringInt)(state.lastUid)(1);
              var newTodos = Data_Array[":"](newTask(uid)(action.value0))(state.todos);
              var _463 = {};
              for (var _464 in state) {
                  if (state.hasOwnProperty(_464)) {
                      _463[_464] = state[_464];
                  };
              };
              _463.lastUid = uid;
              _463.todos = newTodos;
              _463.inputVal = "";
              return _463;
          };
          if (action instanceof Action.Check) {
              var changeTodo = function (t) {
                  var _466 = Prelude["=="](Prelude.eqInt)(t.taskId)(action.value0);
                  if (_466) {
                      var _467 = {};
                      for (var _468 in t) {
                          if (t.hasOwnProperty(_468)) {
                              _467[_468] = t[_468];
                          };
                      };
                      _467.completed = action.value1;
                      return _467;
                  };
                  if (!_466) {
                      return t;
                  };
                  throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/src/Store.purs line 52, column 17 - line 53, column 13: " + [ _466.constructor.name ]);
              };
              var newTodos = Prelude["<$>"](Prelude.functorArray)(changeTodo)(state.todos);
              var _469 = {};
              for (var _470 in state) {
                  if (state.hasOwnProperty(_470)) {
                      _469[_470] = state[_470];
                  };
              };
              _469.todos = newTodos;
              return _469;
          };
          if (action instanceof Action.Delete) {
              var newTodos = Data_Array.filter(function (t) {
                  return Prelude["/="](Prelude.eqInt)(t.taskId)(action.value0);
              })(state.todos);
              var _473 = {};
              for (var _474 in state) {
                  if (state.hasOwnProperty(_474)) {
                      _473[_474] = state[_474];
                  };
              };
              _473.todos = newTodos;
              return _473;
          };
          if (action instanceof Action.ChangedInput) {
              var _476 = {};
              for (var _477 in state) {
                  if (state.hasOwnProperty(_477)) {
                      _476[_477] = state[_477];
                  };
              };
              _476.inputVal = action.value0;
              return _476;
          };
          if (action instanceof Action.DeleteCompleted) {
              var newTodos = Data_Array.filter(function (t) {
                  return Prelude.not(Prelude.booleanAlgebraBoolean)(t.completed);
              })(state.todos);
              var _479 = {};
              for (var _480 in state) {
                  if (state.hasOwnProperty(_480)) {
                      _479[_480] = state[_480];
                  };
              };
              _479.todos = newTodos;
              return _479;
          };
          if (action instanceof Action.Edit) {
              var changeTodo = function (t) {
                  var _481 = Prelude["=="](Prelude.eqInt)(t.taskId)(action.value0);
                  if (_481) {
                      var _482 = {};
                      for (var _483 in t) {
                          if (t.hasOwnProperty(_483)) {
                              _482[_483] = t[_483];
                          };
                      };
                      _482.editing = action.value1;
                      return _482;
                  };
                  if (!_481) {
                      return t;
                  };
                  throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/src/Store.purs line 67, column 17 - line 68, column 13: " + [ _481.constructor.name ]);
              };
              var newTodos = Prelude["<$>"](Prelude.functorArray)(changeTodo)(state.todos);
              var _484 = {};
              for (var _485 in state) {
                  if (state.hasOwnProperty(_485)) {
                      _484[_485] = state[_485];
                  };
              };
              _484.todos = newTodos;
              return _484;
          };
          if (action instanceof Action.ChangeDescription) {
              var changeTodo = function (t) {
                  var _488 = Prelude["=="](Prelude.eqInt)(t.taskId)(action.value0);
                  if (_488) {
                      var _489 = {};
                      for (var _490 in t) {
                          if (t.hasOwnProperty(_490)) {
                              _489[_490] = t[_490];
                          };
                      };
                      _489.description = action.value1;
                      return _489;
                  };
                  if (!_488) {
                      return t;
                  };
                  throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/src/Store.purs line 72, column 17 - line 73, column 13: " + [ _488.constructor.name ]);
              };
              var newTodos = Prelude["<$>"](Prelude.functorArray)(changeTodo)(state.todos);
              var _491 = {};
              for (var _492 in state) {
                  if (state.hasOwnProperty(_492)) {
                      _491[_492] = state[_492];
                  };
              };
              _491.todos = newTodos;
              return _491;
          };
          if (action instanceof Action.ChangeFilter) {
              var _495 = {};
              for (var _496 in state) {
                  if (state.hasOwnProperty(_496)) {
                      _495[_496] = state[_496];
                  };
              };
              _495.filter = action.value0;
              return _495;
          };
          throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/src/Store.purs line 40, column 1 - line 41, column 1: " + [ action.constructor.name ]);
      };
  };
  exports["handleAction"] = handleAction;
  exports["initialAppState"] = initialAppState;;
 
})(PS["Store"] = PS["Store"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Prelude = PS["Prelude"];
  var Signal_Channel = PS["Signal.Channel"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Action = PS["Action"];
  var Data_Array = PS["Data.Array"];
  var Store = PS["Store"];     
  var taskEditableLabel = function (chan) {
      return function (task) {
          if (task.editing) {
              return Incremental_Elements.input([ Incremental_Attributes["type'"]("text"), Incremental_Attributes.value(task.description), Incremental_Attributes["class'"]("task-description"), Incremental_Attributes["onInput'"](Prelude["<<<"](Prelude.semigroupoidFn)(Signal_Channel.send(chan))(Prelude["<<<"](Prelude.semigroupoidFn)(Action.ChangeDescription.create(task.taskId))(Incremental_Attributes.targetValue))), Incremental_Attributes.onBlur(Signal_Channel.send(chan)(new Action.Edit(task.taskId, false))) ])([  ]);
          };
          if (Prelude.otherwise) {
              return Incremental_Elements.label([ Incremental_Attributes["class'"]("task-label"), Incremental_Attributes.onDoubleClick(Signal_Channel.send(chan)(new Action.Edit(task.taskId, true))) ])([ Incremental_DOM.text(task.description) ]);
          };
          throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/src/Components/TaskList.purs line 25, column 1 - line 26, column 1: " + [ chan.constructor.name, task.constructor.name ]);
      };
  };
  var taskItem = function (chan) {
      return function (task) {
          return Incremental_Elements.li([ Incremental_Attributes.key(Prelude.show(Prelude.showInt)(task.taskId)), Incremental_Attributes["class'"]("task-item") ])([ Incremental_Elements.input([ Incremental_Attributes["type'"]("checkbox"), Incremental_Attributes.checked(task.completed), Incremental_Attributes.onClick(Signal_Channel.send(chan)(new Action.Check(task.taskId, Prelude.not(Prelude.booleanAlgebraBoolean)(task.completed)))) ])([  ]), taskEditableLabel(chan)(task), Incremental_Elements["span'"]([ Incremental_Attributes.onClick(Signal_Channel.send(chan)(new Action.Delete(task.taskId))) ])([ Incremental_DOM.text("Ã—") ]) ]);
      };
  };
  var taskList = function (chan) {
      return function (tasks) {
          return Incremental_Elements.ul([ Incremental_Attributes["class'"]("task-list") ])(Prelude["<$>"](Prelude.functorArray)(taskItem(chan))(tasks));
      };
  };
  exports["taskList"] = taskList;;
 
})(PS["Components.TaskList"] = PS["Components.TaskList"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Data_Array = PS["Data.Array"];
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Prelude = PS["Prelude"];
  var Signal_Channel = PS["Signal.Channel"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Action = PS["Action"];
  var Store = PS["Store"];     
  var taskListFooter = function (chan) {
      return function (state) {
          var completedTodos = Data_Array.filter(function (t) {
              return t.completed;
          })(state.todos);
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("task-list-footer") ])([ Incremental_Elements.button([ Incremental_Attributes["type'"]("button"), Incremental_Attributes.onClick(Signal_Channel.send(chan)(Action.DeleteCompleted.value)) ])([ Incremental_DOM.text("Remove completed") ]), Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("task-stats") ])([ Incremental_Elements["span'"]([ Incremental_Attributes["class'"]("total") ])([ Incremental_DOM.text("Total: " + Prelude.show(Prelude.showInt)(Data_Array.length(state.todos))) ]), Incremental_Elements["span'"]([ Incremental_Attributes["class'"]("completed") ])([ Incremental_DOM.text("Completed: " + Prelude.show(Prelude.showInt)(Data_Array.length(completedTodos))) ]) ]) ]);
      };
  };
  exports["taskListFooter"] = taskListFooter;;
 
})(PS["Components.TaskListFooter"] = PS["Components.TaskListFooter"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Prelude = PS["Prelude"];
  var Signal_Channel = PS["Signal.Channel"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Signal = PS["Signal"];
  var Action = PS["Action"];     
  var todoFilter = function (chan) {
      return function (filterStr) {
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("todo-filter") ])([ Incremental_Elements.input([ Incremental_Attributes.placeholder("Enter filter"), Incremental_Attributes.value(filterStr), Incremental_Attributes["type'"]("text"), Incremental_Attributes["onInput'"](Prelude["<<<"](Prelude.semigroupoidFn)(Signal_Channel.send(chan))(Prelude["<<<"](Prelude.semigroupoidFn)(Action.ChangeFilter.create)(Incremental_Attributes.targetValue))) ])([  ]) ]);
      };
  };
  exports["todoFilter"] = todoFilter;;
 
})(PS["Components.TodoFilter"] = PS["Components.TodoFilter"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports._indexOf = function (just) {
    return function (nothing) {
      return function (x) {
        return function (s) {
          var i = s.indexOf(x);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };

  exports.length = function (s) {
    return s.length;
  };
 
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Data.String"];
  var Data_Char = PS["Data.Char"];
  var Prelude = PS["Prelude"];
  var Data_String_Unsafe = PS["Data.String.Unsafe"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];                                                        
  var indexOf = $foreign._indexOf(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var contains = function (x) {
      return function (s) {
          return Data_Maybe.isJust(indexOf(x)(s));
      };
  };
  exports["indexOf"] = indexOf;
  exports["contains"] = contains;
  exports["length"] = $foreign.length;;
 
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_String = PS["Data.String"];
  var Data_Array = PS["Data.Array"];
  var Incremental_Elements = PS["Incremental.Elements"];
  var Incremental_Attributes = PS["Incremental.Attributes"];
  var Components_TaskAdder = PS["Components.TaskAdder"];
  var Components_TodoFilter = PS["Components.TodoFilter"];
  var Components_TaskList = PS["Components.TaskList"];
  var Components_TaskListFooter = PS["Components.TaskListFooter"];
  var Signal_Channel = PS["Signal.Channel"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Action = PS["Action"];
  var Store = PS["Store"];     
  var todoList = function (chan) {
      return function (state) {
          var filteredTasks = (function () {
              if (Prelude[">"](Prelude.ordInt)(Data_String.length(state.filter))(0)) {
                  return Data_Array.filter(function (t) {
                      return Data_String.contains(state.filter)(t.description);
                  })(state.todos);
              };
              if (Prelude.otherwise) {
                  return state.todos;
              };
              throw new Error("Failed pattern match at /Users/simon/purescript-incremental/example/src/Components/TodoList.purs line 27, column 9 - line 29, column 33: " + [  ]);
          })();
          return Incremental_Elements["div'"]([ Incremental_Attributes["class'"]("todo-list") ])([ Components_TaskAdder.taskAdder(chan)(state.inputVal), Components_TodoFilter.todoFilter(chan)(state.filter), Components_TaskList.taskList(chan)(filteredTasks), Components_TaskListFooter.taskListFooter(chan)(state) ]);
      };
  };
  exports["todoList"] = todoList;;
 
})(PS["Components.TodoList"] = PS["Components.TodoList"] || {});
(function(exports) {
  /* global exports, window */
  "use strict";

  // module DOM.HTML

  exports.window = function () {
    return window;
  };
 
})(PS["DOM.HTML"] = PS["DOM.HTML"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["DOM.HTML.Types"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];
  var Data_Foreign = PS["Data.Foreign"];
  var Prelude = PS["Prelude"];
  var Data_Either = PS["Data.Either"];
  var Data_Foreign_Class = PS["Data.Foreign.Class"];
  var DOM_Event_Types = PS["DOM.Event.Types"];
  var DOM_Node_Types = PS["DOM.Node.Types"];                
  var htmlElementToElement = Unsafe_Coerce.unsafeCoerce;
  exports["htmlElementToElement"] = htmlElementToElement;;
 
})(PS["DOM.HTML.Types"] = PS["DOM.HTML.Types"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["DOM.HTML"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  exports["window"] = $foreign.window;;
 
})(PS["DOM.HTML"] = PS["DOM.HTML"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module DOM.HTML.Document

  exports.body = function (doc) {
    return function () {
      return doc.body;
    };
  };
 
})(PS["DOM.HTML.Document"] = PS["DOM.HTML.Document"] || {});
(function(exports) {
  /* global exports */
  "use strict";          

  exports.nullable = function(a, r, f) {
      return a == null ? r : f(a);
  }; 
 
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["Data.Nullable"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Function = PS["Data.Function"];
  var Prelude = PS["Prelude"];                                          
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;;
 
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["DOM.HTML.Document"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Nullable = PS["Data.Nullable"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  exports["body"] = $foreign.body;;
 
})(PS["DOM.HTML.Document"] = PS["DOM.HTML.Document"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module DOM.HTML.Window

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };
 
})(PS["DOM.HTML.Window"] = PS["DOM.HTML.Window"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var $foreign = PS["DOM.HTML.Window"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM = PS["DOM"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  exports["document"] = $foreign.document;;
 
})(PS["DOM.HTML.Window"] = PS["DOM.HTML.Window"] || {});
(function(exports) {
  // Generated by psc version 0.7.0.0
  "use strict";
  var Prelude = PS["Prelude"];
  var DOM_HTML_Types = PS["DOM.HTML.Types"];
  var Data_Maybe_Unsafe = PS["Data.Maybe.Unsafe"];
  var Data_Nullable = PS["Data.Nullable"];
  var DOM_HTML = PS["DOM.HTML"];
  var DOM_HTML_Window = PS["DOM.HTML.Window"];
  var DOM_HTML_Document = PS["DOM.HTML.Document"];
  var Signal = PS["Signal"];
  var Store = PS["Store"];
  var Components_TodoList = PS["Components.TodoList"];
  var Incremental_DOM = PS["Incremental.DOM"];
  var Signal_Channel = PS["Signal.Channel"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var DOM_Node_Types = PS["DOM.Node.Types"];
  var DOM = PS["DOM"];
  var Action = PS["Action"];     
  var body = Prelude["<$>"](Control_Monad_Eff.functorEff)(Prelude["<$>"](Prelude.functorFn)(Prelude["<$>"](Prelude.functorFn)(DOM_HTML_Types.htmlElementToElement)(Data_Maybe_Unsafe.fromJust))(Data_Nullable.toMaybe))(Prelude[">>="](Control_Monad_Eff.bindEff)(Prelude[">>="](Control_Monad_Eff.bindEff)(DOM_HTML.window)(DOM_HTML_Window.document))(DOM_HTML_Document.body));
  var renderAction = function (chan) {
      return function (action) {
          return Signal.runSignal(Signal["~>"](Signal.functorSignal)(Signal["~>"](Signal.functorSignal)(Signal["~>"](Signal.functorSignal)(Signal.foldp(Store.handleAction)(Store.initialAppState)(action))(Components_TodoList.todoList(chan)))(Incremental_DOM.patch))(Prelude.bind(Control_Monad_Eff.bindEff)(body)));
      };
  };
  var main = function __do() {
      var _17 = Signal_Channel.channel(Action.NoOp.value)();
      return renderAction(_17)(Signal_Channel.subscribe(_17))();
  };
  exports["main"] = main;
  exports["renderAction"] = renderAction;
  exports["body"] = body;;
 
})(PS["Main"] = PS["Main"] || {});

PS["Main"].main();

},{"incremental-dom":2}],2:[function(require,module,exports){
(function (process){

/**
 * @license
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** */
exports.notifications = {
  /**
   * Called after patch has compleated with any Nodes that have been created
   * and added to the DOM.
   * @type {?function(Array<!Node>)}
   */
  nodesCreated: null,

  /**
   * Called after patch has compleated with any Nodes that have been removed
   * from the DOM.
   * Note it's an applications responsibility to handle any childNodes.
   * @type {?function(Array<!Node>)}
   */
  nodesDeleted: null
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Similar to the built-in Treewalker class, but simplified and allows direct
 * access to modify the currentNode property.
 * @param {!Element|!DocumentFragment} node The root Node of the subtree the
 *     walker should start traversing.
 * @constructor
 */
function TreeWalker(node) {
  /**
   * Keeps track of the current parent node. This is necessary as the traversal
   * methods may traverse past the last child and we still need a way to get
   * back to the parent.
   * @const @private {!Array<!Node>}
   */
  this.stack_ = [];

  /**
   * @const {!Element|!DocumentFragment}
   */
  this.root = node;

  /**
   * @type {?Node}
   */
  this.currentNode = node;
}

/**
 * @return {!Node} The current parent of the current location in the subtree.
 */
TreeWalker.prototype.getCurrentParent = function () {
  return this.stack_[this.stack_.length - 1];
};

/**
 * Changes the current location the firstChild of the current location.
 */
TreeWalker.prototype.firstChild = function () {
  this.stack_.push(this.currentNode);
  this.currentNode = this.currentNode.firstChild;
};

/**
 * Changes the current location the nextSibling of the current location.
 */
TreeWalker.prototype.nextSibling = function () {
  this.currentNode = this.currentNode.nextSibling;
};

/**
 * Changes the current location the parentNode of the current location.
 */
TreeWalker.prototype.parentNode = function () {
  this.currentNode = this.stack_.pop();
};

/**
 * Keeps track of the state of a patch.
 * @param {!Element|!DocumentFragment} node The root Node of the subtree the
 *     is for.
 * @param {?Context} prevContext The previous context.
 * @constructor
 */
function Context(node, prevContext) {
  /**
   * @const {TreeWalker}
   */
  this.walker = new TreeWalker(node);

  /**
   * @const {Document}
   */
  this.doc = node.ownerDocument;

  /**
   * Keeps track of what namespace to create new Elements in.
   * @private
   * @const {!Array<(string|undefined)>}
   */
  this.nsStack_ = [undefined];

  /**
   * @const {?Context}
   */
  this.prevContext = prevContext;

  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.created = exports.notifications.nodesCreated && [];

  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.deleted = exports.notifications.nodesDeleted && [];
}

/**
 * @return {(string|undefined)} The current namespace to create Elements in.
 */
Context.prototype.getCurrentNamespace = function () {
  return this.nsStack_[this.nsStack_.length - 1];
};

/**
 * @param {string=} namespace The namespace to enter.
 */
Context.prototype.enterNamespace = function (namespace) {
  this.nsStack_.push(namespace);
};

/**
 * Exits the current namespace
 */
Context.prototype.exitNamespace = function () {
  this.nsStack_.pop();
};

/**
 * @param {!Node} node
 */
Context.prototype.markCreated = function (node) {
  if (this.created) {
    this.created.push(node);
  }
};

/**
 * @param {!Node} node
 */
Context.prototype.markDeleted = function (node) {
  if (this.deleted) {
    this.deleted.push(node);
  }
};

/**
 * Notifies about nodes that were created during the patch opearation.
 */
Context.prototype.notifyChanges = function () {
  if (this.created && this.created.length > 0) {
    exports.notifications.nodesCreated(this.created);
  }

  if (this.deleted && this.deleted.length > 0) {
    exports.notifications.nodesDeleted(this.deleted);
  }
};

/**
 * The current context.
 * @type {?Context}
 */
var context;

/**
 * Enters a new patch context.
 * @param {!Element|!DocumentFragment} node
 */
var enterContext = function (node) {
  context = new Context(node, context);
};

/**
 * Restores the previous patch context.
 */
var restoreContext = function () {
  context = context.prevContext;
};

/**
 * Gets the current patch context.
 * @return {?Context}
 */
var getContext = function () {
  return context;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A cached reference to the hasOwnProperty function.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * A cached reference to the create function.
 */
var create = Object.create;

/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param {!Object<string, *>} map The map to check.
 * @param {string} property The property to check.
 * @return {boolean} Whether map has property.
 */
var has = function (map, property) {
  return hasOwnProperty.call(map, property);
};

/**
 * Creates an map object without a prototype.
 * @return {!Object}
 */
var createMap = function () {
  return create(null);
};

/**
 * Keeps track of information needed to perform diffs for a given DOM node.
 * @param {!string} nodeName
 * @param {?string=} key
 * @constructor
 */
function NodeData(nodeName, key) {
  /**
   * The attributes and their values.
   * @const
   */
  this.attrs = createMap();

  /**
   * An array of attribute name/value pairs, used for quickly diffing the
   * incomming attributes to see if the DOM node's attributes need to be
   * updated.
   * @const {Array<*>}
   */
  this.attrsArr = [];

  /**
   * The incoming attributes for this Node, before they are updated.
   * @const {!Object<string, *>}
   */
  this.newAttrs = createMap();

  /**
   * The key used to identify this node, used to preserve DOM nodes when they
   * move within their parent.
   * @const
   */
  this.key = key;

  /**
   * Keeps track of children within this node by their key.
   * {?Object<string, !Element>}
   */
  this.keyMap = null;

  /**
   * Whether or not the keyMap is currently valid.
   * {boolean}
   */
  this.keyMapValid = true;

  /**
   * The last child to have been visited within the current pass.
   * @type {?Node}
   */
  this.lastVisitedChild = null;

  /**
   * The node name for this node.
   * @const {string}
   */
  this.nodeName = nodeName;

  /**
   * @type {?string}
   */
  this.text = null;
}

/**
 * Initializes a NodeData object for a Node.
 *
 * @param {Node} node The node to initialize data for.
 * @param {string} nodeName The node name of node.
 * @param {?string=} key The key that identifies the node.
 * @return {!NodeData} The newly initialized data object
 */
var initData = function (node, nodeName, key) {
  var data = new NodeData(nodeName, key);
  node['__incrementalDOMData'] = data;
  return data;
};

/**
 * Retrieves the NodeData object for a Node, creating it if necessary.
 *
 * @param {Node} node The node to retrieve the data for.
 * @return {!NodeData} The NodeData for this Node.
 */
var getData = function (node) {
  var data = node['__incrementalDOMData'];

  if (!data) {
    var nodeName = node.nodeName.toLowerCase();
    var key = null;

    if (node instanceof Element) {
      key = node.getAttribute('key');
    }

    data = initData(node, nodeName, key);
  }

  return data;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.symbols = {
  default: '__default',

  placeholder: '__placeholder'
};

/**
 * Applies an attribute or property to a given Element. If the value is null
 * or undefined, it is removed from the Element. Otherwise, the value is set
 * as an attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {?(boolean|number|string)=} value The attribute's value.
 */
exports.applyAttr = function (el, name, value) {
  if (value == null) {
    el.removeAttribute(name);
  } else {
    el.setAttribute(name, value);
  }
};

/**
 * Applies a property to a given Element.
 * @param {!Element} el
 * @param {string} name The property's name.
 * @param {*} value The property's value.
 */
exports.applyProp = function (el, name, value) {
  el[name] = value;
};

/**
 * Applies a style to an Element. No vendor prefix expansion is done for
 * property names/values.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {string|Object<string,string>} style The style to set. Either a
 *     string of css or an object containing property-value pairs.
 */
var applyStyle = function (el, name, style) {
  if (typeof style === 'string') {
    el.style.cssText = style;
  } else {
    el.style.cssText = '';
    var elStyle = el.style;

    for (var prop in style) {
      if (has(style, prop)) {
        elStyle[prop] = style[prop];
      }
    }
  }
};

/**
 * Updates a single attribute on an Element.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value. If the value is an object or
 *     function it is set on the Element, otherwise, it is set as an HTML
 *     attribute.
 */
var applyAttributeTyped = function (el, name, value) {
  var type = typeof value;

  if (type === 'object' || type === 'function') {
    exports.applyProp(el, name, value);
  } else {
    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
  }
};

/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
var updateAttribute = function (el, name, value) {
  var data = getData(el);
  var attrs = data.attrs;

  if (attrs[name] === value) {
    return;
  }

  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];
  mutator(el, name, value);

  attrs[name] = value;
};

/**
 * A publicly mutable object to provide custom mutators for attributes.
 * @const {!Object<string, function(!Element, string, *)>}
 */
exports.attributes = createMap();

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
exports.attributes[exports.symbols.default] = applyAttributeTyped;

exports.attributes[exports.symbols.placeholder] = function () {};

exports.attributes['style'] = applyStyle;

var SVG_NS = 'http://www.w3.org/2000/svg';

/**
 * Enters a tag, checking to see if it is a namespace boundary, and if so,
 * updates the current namespace.
 * @param {string} tag The tag to enter.
 */
var enterTag = function (tag) {
  if (tag === 'svg') {
    getContext().enterNamespace(SVG_NS);
  } else if (tag === 'foreignObject') {
    getContext().enterNamespace(undefined);
  }
};

/**
 * Exits a tag, checking to see if it is a namespace boundary, and if so,
 * updates the current namespace.
 * @param {string} tag The tag to enter.
 */
var exitTag = function (tag) {
  if (tag === 'svg' || tag === 'foreignObject') {
    getContext().exitNamespace();
  }
};

/**
 * Gets the namespace to create an element (of a given tag) in.
 * @param {string} tag The tag to get the namespace for.
 * @return {(string|undefined)} The namespace to create the tag in.
 */
var getNamespaceForTag = function (tag) {
  if (tag === 'svg') {
    return SVG_NS;
  }

  return getContext().getCurrentNamespace();
};

/**
 * Creates an Element.
 * @param {Document} doc The document with which to create the Element.
 * @param {string} tag The tag for the Element.
 * @param {?string=} key A key to identify the Element.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of
 *     the static attributes for the Element.
 * @return {!Element}
 */
var createElement = function (doc, tag, key, statics) {
  var namespace = getNamespaceForTag(tag);
  var el;

  if (namespace) {
    el = doc.createElementNS(namespace, tag);
  } else {
    el = doc.createElement(tag);
  }

  initData(el, tag, key);

  if (statics) {
    for (var i = 0; i < statics.length; i += 2) {
      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);
    }
  }

  return el;
};

/**
 * Creates a Node, either a Text or an Element depending on the node name
 * provided.
 * @param {Document} doc The document with which to create the Node.
 * @param {string} nodeName The tag if creating an element or #text to create
 *     a Text.
 * @param {?string=} key A key to identify the Element.
 * @param {?Array<*>=} statics The static data to initialize the Node
 *     with. For an Element, an array of attribute name/value pairs of
 *     the static attributes for the Element.
 * @return {!Node}
 */
var createNode = function (doc, nodeName, key, statics) {
  if (nodeName === '#text') {
    return doc.createTextNode('');
  }

  return createElement(doc, nodeName, key, statics);
};

/**
 * Creates a mapping that can be used to look up children using a key.
 * @param {!Node} el
 * @return {!Object<string, !Element>} A mapping of keys to the children of the
 *     Element.
 */
var createKeyMap = function (el) {
  var map = createMap();
  var children = el.children;
  var count = children.length;

  for (var i = 0; i < count; i += 1) {
    var child = children[i];
    var key = getData(child).key;

    if (key) {
      map[key] = child;
    }
  }

  return map;
};

/**
 * Retrieves the mapping of key to child node for a given Element, creating it
 * if necessary.
 * @param {!Node} el
 * @return {!Object<string, !Node>} A mapping of keys to child Elements
 */
var getKeyMap = function (el) {
  var data = getData(el);

  if (!data.keyMap) {
    data.keyMap = createKeyMap(el);
  }

  return data.keyMap;
};

/**
 * Retrieves a child from the parent with the given key.
 * @param {!Node} parent
 * @param {?string=} key
 * @return {?Element} The child corresponding to the key.
 */
var getChild = function (parent, key) {
  return (/** @type {?Element} */key && getKeyMap(parent)[key]
  );
};

/**
 * Registers an element as being a child. The parent will keep track of the
 * child using the key. The child can be retrieved using the same key using
 * getKeyMap. The provided key should be unique within the parent Element.
 * @param {!Node} parent The parent of child.
 * @param {string} key A key to identify the child with.
 * @param {!Node} child The child to register.
 */
var registerChild = function (parent, key, child) {
  getKeyMap(parent)[key] = child;
};

if (process.env.NODE_ENV !== 'production') {
  /**
  * Makes sure that keyed Element matches the tag name provided.
  * @param {!Element} node The node that is being matched.
  * @param {string=} tag The tag name of the Element.
  * @param {?string=} key The key of the Element.
  */
  var assertKeyedTagMatches = function (node, tag, key) {
    var nodeName = getData(node).nodeName;
    if (nodeName !== tag) {
      throw new Error('Was expecting node with key "' + key + '" to be a ' + tag + ', not a ' + nodeName + '.');
    }
  };
}

/**
 * Checks whether or not a given node matches the specified nodeName and key.
 *
 * @param {!Node} node An HTML node, typically an HTMLElement or Text.
 * @param {?string} nodeName The nodeName for this node.
 * @param {?string=} key An optional key that identifies a node.
 * @return {boolean} True if the node matches, false otherwise.
 */
var matches = function (node, nodeName, key) {
  var data = getData(node);

  // Key check is done using double equals as we want to treat a null key the
  // same as undefined. This should be okay as the only values allowed are
  // strings, null and undefined so the == semantics are not too weird.
  return key == data.key && nodeName === data.nodeName;
};

/**
 * Aligns the virtual Element definition with the actual DOM, moving the
 * corresponding DOM node to the correct location or creating it if necessary.
 * @param {string} nodeName For an Element, this should be a valid tag string.
 *     For a Text, this should be #text.
 * @param {?string=} key The key used to identify this element.
 * @param {?Array<*>=} statics For an Element, this should be an array of
 *     name-value pairs.
 * @return {!Node} The matching node.
 */
var alignWithDOM = function (nodeName, key, statics) {
  var context = getContext();
  var walker = context.walker;
  var currentNode = walker.currentNode;
  var parent = walker.getCurrentParent();
  var matchingNode;

  // Check to see if we have a node to reuse
  if (currentNode && matches(currentNode, nodeName, key)) {
    matchingNode = currentNode;
  } else {
    var existingNode = getChild(parent, key);

    // Check to see if the node has moved within the parent or if a new one
    // should be created
    if (existingNode) {
      if (process.env.NODE_ENV !== 'production') {
        assertKeyedTagMatches(existingNode, nodeName, key);
      }

      matchingNode = existingNode;
    } else {
      matchingNode = createNode(context.doc, nodeName, key, statics);

      if (key) {
        registerChild(parent, key, matchingNode);
      }

      context.markCreated(matchingNode);
    }

    // If the node has a key, remove it from the DOM to prevent a large number
    // of re-orders in the case that it moved far or was completely removed.
    // Since we hold on to a reference through the keyMap, we can always add it
    // back.
    if (currentNode && getData(currentNode).key) {
      parent.replaceChild(matchingNode, currentNode);
      getData(parent).keyMapValid = false;
    } else {
      parent.insertBefore(matchingNode, currentNode);
    }

    walker.currentNode = matchingNode;
  }

  return matchingNode;
};

/**
 * Clears out any unvisited Nodes, as the corresponding virtual element
 * functions were never called for them.
 * @param {Node} node
 */
var clearUnvisitedDOM = function (node) {
  var context = getContext();
  var walker = context.walker;
  var data = getData(node);
  var keyMap = data.keyMap;
  var keyMapValid = data.keyMapValid;
  var lastVisitedChild = data.lastVisitedChild;
  var child = node.lastChild;
  var key;

  data.lastVisitedChild = null;

  if (child === lastVisitedChild && keyMapValid) {
    return;
  }

  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {
    return;
  }

  while (child !== lastVisitedChild) {
    node.removeChild(child);
    context.markDeleted( /** @type {!Node}*/child);

    key = getData(child).key;
    if (key) {
      delete keyMap[key];
    }
    child = node.lastChild;
  }

  // Clean the keyMap, removing any unusued keys.
  for (key in keyMap) {
    child = keyMap[key];
    if (!child.parentNode) {
      context.markDeleted(child);
      delete keyMap[key];
    }
  }

  data.keyMapValid = true;
};

/**
 * Enters an Element, setting the current namespace for nested elements.
 * @param {Node} node
 */
var enterNode = function (node) {
  var data = getData(node);
  enterTag(data.nodeName);
};

/**
 * Exits an Element, unwinding the current namespace to the previous value.
 * @param {Node} node
 */
var exitNode = function (node) {
  var data = getData(node);
  exitTag(data.nodeName);
};

/**
 * Marks node's parent as having visited node.
 * @param {Node} node
 */
var markVisited = function (node) {
  var context = getContext();
  var walker = context.walker;
  var parent = walker.getCurrentParent();
  var data = getData(parent);
  data.lastVisitedChild = node;
};

/**
 * Changes to the first child of the current node.
 */
var firstChild = function () {
  var context = getContext();
  var walker = context.walker;
  enterNode(walker.currentNode);
  walker.firstChild();
};

/**
 * Changes to the next sibling of the current node.
 */
var nextSibling = function () {
  var context = getContext();
  var walker = context.walker;
  markVisited(walker.currentNode);
  walker.nextSibling();
};

/**
 * Changes to the parent of the current node, removing any unvisited children.
 */
var parentNode = function () {
  var context = getContext();
  var walker = context.walker;
  walker.parentNode();
  exitNode(walker.currentNode);
};

if (process.env.NODE_ENV !== 'production') {
  var assertNoUnclosedTags = function (root) {
    var openElement = getContext().walker.getCurrentParent();
    if (!openElement) {
      return;
    }

    var openTags = [];
    while (openElement && openElement !== root) {
      openTags.push(openElement.nodeName.toLowerCase());
      openElement = openElement.parentNode;
    }

    throw new Error('One or more tags were not closed:\n' + openTags.join('\n'));
  };
}

/**
 * Patches the document starting at el with the provided function. This function
 * may be called during an existing patch operation.
 * @param {!Element|!DocumentFragment} node The Element or Document
 *     to patch.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @template T
 */
exports.patch = function (node, fn, data) {
  enterContext(node);

  firstChild();
  fn(data);
  parentNode();
  clearUnvisitedDOM(node);

  if (process.env.NODE_ENV !== 'production') {
    assertNoUnclosedTags(node);
  }

  getContext().notifyChanges();
  restoreContext();
};

/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
var ATTRIBUTES_OFFSET = 3;

/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {Array<*>}
 */
var argsBuilder = [];

if (process.env.NODE_ENV !== 'production') {
  /**
   * Keeps track whether or not we are in an attributes declaration (after
   * elementOpenStart, but before elementOpenEnd).
   * @type {boolean}
   */
  var inAttributes = false;

  /** Makes sure that the caller is not where attributes are expected. */
  var assertNotInAttributes = function () {
    if (inAttributes) {
      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' + 'they must follow a call to elementOpenStart.');
    }
  };

  /** Makes sure that the caller is where attributes are expected. */
  var assertInAttributes = function () {
    if (!inAttributes) {
      throw new Error('Was expecting a call to attr or elementOpenEnd. ' + 'elementOpenStart must be followed by zero or more calls to attr, ' + 'then one call to elementOpenEnd.');
    }
  };

  /**
   * Makes sure that placeholders have a key specified. Otherwise, conditional
   * placeholders and conditional elements next to placeholders will cause
   * placeholder elements to be re-used as non-placeholders and vice versa.
   * @param {string} key
   */
  var assertPlaceholderKeySpecified = function (key) {
    if (!key) {
      throw new Error('Placeholder elements must have a key specified.');
    }
  };

  /**
   * Makes sure that tags are correctly nested.
   * @param {string} tag
   */
  var assertCloseMatchesOpenTag = function (tag) {
    var context = getContext();
    var walker = context.walker;
    var closingNode = walker.getCurrentParent();
    var data = getData(closingNode);

    if (tag !== data.nodeName) {
      throw new Error('Received a call to close ' + tag + ' but ' + data.nodeName + ' was open.');
    }
  };

  /** Updates the state to being in an attribute declaration. */
  var setInAttributes = function () {
    inAttributes = true;
  };

  /** Updates the state to not being in an attribute declaration. */
  var setNotInAttributes = function () {
    inAttributes = false;
  };
}

/**
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
exports.elementOpen = function (tag, key, statics, var_args) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
  }

  var node = /** @type {!Element}*/alignWithDOM(tag, key, statics);
  var data = getData(node);

  /*
   * Checks to see if one or more attributes have changed for a given Element.
   * When no attributes have changed, this is much faster than checking each
   * individual argument. When attributes have changed, the overhead of this is
   * minimal.
   */
  var attrsArr = data.attrsArr;
  var attrsChanged = false;
  var i = ATTRIBUTES_OFFSET;
  var j = 0;

  for (; i < arguments.length; i += 1, j += 1) {
    if (attrsArr[j] !== arguments[i]) {
      attrsChanged = true;
      break;
    }
  }

  for (; i < arguments.length; i += 1, j += 1) {
    attrsArr[j] = arguments[i];
  }

  if (j < attrsArr.length) {
    attrsChanged = true;
    attrsArr.length = j;
  }

  /*
   * Actually perform the attribute update.
   */
  if (attrsChanged) {
    var attr,
        newAttrs = data.newAttrs;

    for (attr in newAttrs) {
      newAttrs[attr] = undefined;
    }

    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {
      newAttrs[arguments[i]] = arguments[i + 1];
    }

    for (attr in newAttrs) {
      updateAttribute(node, attr, newAttrs[attr]);
    }
  }

  firstChild();
  return node;
};

/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 */
exports.elementOpenStart = function (tag, key, statics) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
    setInAttributes();
  }

  argsBuilder[0] = tag;
  argsBuilder[1] = key;
  argsBuilder[2] = statics;
};

/***
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name
 * @param {*} value
 */
exports.attr = function (name, value) {
  if (process.env.NODE_ENV !== 'production') {
    assertInAttributes();
  }

  argsBuilder.push(name, value);
};

/**
 * Closes an open tag started with elementOpenStart.
 * @return {!Element} The corresponding Element.
 */
exports.elementOpenEnd = function () {
  if (process.env.NODE_ENV !== 'production') {
    assertInAttributes();
    setNotInAttributes();
  }

  var node = exports.elementOpen.apply(null, argsBuilder);
  argsBuilder.length = 0;
  return node;
};

/**
 * Closes an open virtual Element.
 *
 * @param {string} tag The element's tag.
 * @return {!Element} The corresponding Element.
 */
exports.elementClose = function (tag) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
    assertCloseMatchesOpenTag(tag);
  }

  parentNode();

  var node = /** @type {!Element} */getContext().walker.currentNode;

  clearUnvisitedDOM(node);

  nextSibling();
  return node;
};

/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
exports.elementVoid = function (tag, key, statics, var_args) {
  var node = exports.elementOpen.apply(null, arguments);
  exports.elementClose.apply(null, arguments);
  return node;
};

/**
 * Declares a virtual Element at the current location in the document that is a
 * placeholder element. Children of this Element can be manually managed and
 * will not be cleared by the library.
 *
 * A key must be specified to make sure that this node is correctly preserved
 * across all conditionals.
 *
 * @param {string} tag The element's tag.
 * @param {string} key The key used to identify this element.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
exports.elementPlaceholder = function (tag, key, statics, var_args) {
  if (process.env.NODE_ENV !== 'production') {
    assertPlaceholderKeySpecified(key);
  }

  var node = exports.elementOpen.apply(null, arguments);
  updateAttribute(node, exports.symbols.placeholder, true);
  exports.elementClose.apply(null, arguments);
  return node;
};

/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} var_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 * @return {!Text} The corresponding text node.
 */
exports.text = function (value, var_args) {
  if (process.env.NODE_ENV !== 'production') {
    assertNotInAttributes();
  }

  var node = /** @type {!Text}*/alignWithDOM('#text', null);
  var data = getData(node);

  if (data.text !== value) {
    data.text = /** @type {string} */value;

    var formatted = value;
    for (var i = 1; i < arguments.length; i += 1) {
      formatted = arguments[i](formatted);
    }

    node.data = formatted;
  }

  nextSibling();
  return node;
};

}).call(this,require('_process'))
},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1]);
